#ifndef REALSURF_GLSL_VERT
#include <string>
#define REALSURF_GLSL_VERT ( string( "uniform mat4 surface_transform_inverse;\r\n\r\nvarying vec3 eye_space_eye;\r\nvarying vec3 eye_space_dir;\r\nvarying vec3 clipping_space_eye;\r\nvarying vec3 clipping_space_dir;\r\nvarying vec3 surface_space_eye;\r\nvarying vec3 surface_space_dir;\r\n\r\nvoid main( void )\r\n{\r\n\t// calculate raster position by standard opengl procedure\r\n\tgl_Position = ftransform();\r\n\t\r\n\t// calculate ray in different coordinate systems\r\n\teye_space_eye = ( gl_ModelViewMatrix * gl_Vertex ).xyz;\r\n\teye_space_dir = ( eye_space_eye );\r\n\t\r\n\tclipping_space_eye = gl_Vertex.xyz;\r\n\tclipping_space_dir = ( clipping_space_eye - ( gl_ModelViewMatrixInverse * vec4( 0.0, 0.0, 0.0, 1.0 ) ).xyz );\r\n\t\r\n\tsurface_space_eye = ( surface_transform_inverse * gl_Vertex ).xyz;\r\n\tsurface_space_dir = ( surface_space_eye - ( surface_transform_inverse * gl_ModelViewMatrixInverse * vec4( 0.0, 0.0, 0.0, 1.0 ) ).xyz );\r\n}" ) )
#endif
#ifndef REALSURF_GLSL_FRAG_STUB
#include <string>
#define REALSURF_GLSL_FRAG_STUB ( string( "#define MAX_LIGHTS 3\r\n\r\nuniform mat4 surface_transform_inverse;\r\nuniform mat4 surface_transform;\r\n\r\nuniform int clip_to;\r\n\r\nvarying vec3 eye_space_eye;\r\nvarying vec3 eye_space_dir;\r\nvarying vec3 surface_space_eye;\r\nvarying vec3 surface_space_dir;\r\nvarying vec3 clipping_space_eye;\r\nvarying vec3 clipping_space_dir;\r\n\r\nvec3 ese_opt, esd_opt, cse_opt, csd_opt, sse_opt, ssd_opt;\r\n\r\npolynomial calc_coefficients( vec3 eye, vec3 dir );\r\nvec3 gradient( vec3 p );\r\n\r\n#define CLIP_TO_SPHERE 1\r\n#define CLIP_TO_CUBE 2\r\n\r\n#ifdef METHOD_LAGRANGE_INTERPOLATION\r\n/******************************************************\r\n * Die hier verwendete Interpolationsmethode ist eine\r\n * Portierung des optimierten Lagrange-Algorithmus aus\r\n *\r\n *  Numerical Recipes in C: The Art of Scientific Computing\r\n *  William H. Press et al.\r\n *  Cambridge University Press\r\n *  2. Auflage (1996)\r\n *  ISBN 0-521-43108-5\r\n *  Seite 121\r\n ******************************************************/\r\npolynomial calc_coefficients( vec3 eye, vec3 dir, vec2 clipping_interval )\r\n{\r\n\t// DEGREE + 1 Stützpunkte auf Strahl eye + t * pos berechnen\r\n\tfloat y[ SIZE ];\r\n\tfloat x[ SIZE ];\r\n\tfloat ci_width = clipping_interval[ 1 ] - clipping_interval[ 0 ];\r\n\tfor( int i = 0; i <= DEGREE; i++ )\r\n\t{\r\n\t\tx[ i ] = clipping_interval[ 0 ] + ( float( i ) / float( DEGREE ) ) * ci_width;\r\n\t\tvec3 p = eye + x[ i ] * dir;\r\n\t\ty[ i ] = f( p.x, p.y, p.z );\r\n\t}\r\n\r\n\tpolynomial p;\r\n\tfloat s[ SIZE ];\r\n\tfor( int i = 0; i < SIZE; i++ )\r\n\t\ts[ i ] = p.a[ i ] = 0.0;\r\n\ts[ SIZE - 1 ] = -x[ 0 ];\r\n\tfor( int i = 1; i < SIZE; i++ )\r\n\t{\r\n\t\tfor( int j = SIZE - 1 - i; j < SIZE - 1; j++ )\r\n\t\t\ts[ j ] -= x[ i ] * s[ j + 1 ];\r\n\t\ts[ SIZE - 1 ] -= x[ i ];\r\n\t}\r\n\tfor( int j = 0; j < SIZE; j++ )\r\n\t{\r\n\t\tfloat phi = float( SIZE );\r\n\t\tfor( int k = SIZE - 1; k >= 1; k-- )\r\n\t\t\tphi = float( k ) * s[ k ] + x[ j ] * phi;\r\n\t\tfloat ff = y[ j ] / phi;\r\n\t\tfloat b = 1.0;\r\n\t\tfor( int k = SIZE - 1; k >= 0; k-- )\r\n\t\t{\r\n\t\t\tp.a[ k ] += b * ff;\r\n\t\t\tb = s[ k ] + x[ j ] * b;\r\n\t\t}\r\n\t}\r\n\treturn p;\r\n}\r\n#endif\r\n\r\n#ifdef METHOD_NEWTON_INTERPOLATION\r\npolynomial calc_coefficients( vec3 eye, vec3 dir, vec2 clipping_interval )\r\n{\r\n\t// DEGREE + 1 Stützpunkte auf Strahl eye + t * pos berechnen\r\n\tfloat y[ SIZE ];\r\n\tfloat x[ SIZE ];\r\n\tfloat ci_width = clipping_interval[ 1 ] - clipping_interval[ 0 ];\r\n\tfor( int i = 0; i <= DEGREE; i++ )\r\n\t{\r\n\t\tx[ i ] = clipping_interval[ 0 ] + ( float( i ) / float( DEGREE ) ) * ci_width;\r\n\t\tvec3 p = eye + x[ i ] * dir;\r\n\t\ty[ i ] = f( p.x, p.y, p.z );\r\n\t}\r\n\r\n\t// dividierte Differenzen berechen\r\n\tfor( int i = 1; i <= DEGREE; i++ )\r\n\t\tfor( int j = DEGREE; j >= i; j-- )\r\n\t\t\ty[ j ] = ( y[ j ] - y[ j - 1 ] ) / ( x[ j ] - x[ j - i ] );\r\n\r\n\t// schrittweise Koeffizienten mit Newton-Interpolationsformel berechnen\r\n\tpolynomial p;\r\n\tfloat newton_basis[ SIZE ];\r\n\r\n\tnewton_basis[ DEGREE ] = 1.0;\r\n\tp.a[ 0 ] = y[ 0 ];\r\n\t\r\n\tfor( int i = 1; i <= DEGREE; i++ )\r\n\t{\r\n\t\t// ( ai*x^i + ... + a0 ) + ( ai*x^i + ... + a0 ) * ( x - x[ i ] ) * y[ i ] = ( ai*x^i + ... + a0 ) * x - x[ i ] * y[ i ] * ( ai*x^i + ... + a0 ) berechnen\r\n\t\t// 1. Koeffizienten der Newton-Basis um eine Potenz erhöhen (=shiften)\r\n\t\tnewton_basis[ DEGREE - i ] = 0.0;\r\n\t\tp.a[ i ] = 0.0;\r\n\t\t\r\n\t\t// 2. alte Koeffizienten der Newton-Basis multipliziert mit x[ i - 1 ] subtrahieren\r\n\t\tfor( int j = DEGREE - i; j < DEGREE; j++ )\r\n\t\t\tnewton_basis[ j ] = newton_basis[ j ] - newton_basis[ j + 1 ] * x[ i - 1 ];\r\n\r\n\t\t// 3. y[ i ] * ( neue Newton-Basis ) auf alte Koeffizienten addieren\r\n\t\tfor( int j = 0; j <= i; j++ )\r\n\t\t\tp.a[ j ] += newton_basis[ DEGREE - i + j ] * y[ i ];\r\n\t}\r\n\treturn p;\r\n}\r\n#endif\r\n\r\n#ifdef METHOD_COMPUTER_ALGEBRA\r\npolynomial create_poly_0( float a0 )\r\n{\r\n\tpolynomial res;\r\n\tfor( int i = 1; i <= DEGREE; i++ )\r\n\t\tres.a[ i ] = 0" ) + string( ".0;\r\n\tres.a[ 0 ] = a0;\r\n\treturn res;\r\n}\r\n\r\npolynomial create_poly_1( float a0, float a1 )\r\n{\r\n\tpolynomial res;\r\n#if DEGREE > 1\r\n\tfor( int i = 2; i <= DEGREE; i++ )\r\n\t\tres.a[ i ] = 0.0;\r\n#endif\r\n\tres.a[ 0 ] = a0;\r\n\tres.a[ 1 ] = a1;\r\n\treturn res;\r\n}\r\n\r\npolynomial add( polynomial p1, polynomial p2, int res_degree )\r\n{\r\n\tfor( int i = 0; i <= res_degree; i++ )\r\n\t\tp1.a[ i ] += p2.a[ i ];\r\n\treturn p1;\r\n}\r\n\r\npolynomial sub( polynomial p1, polynomial p2, int res_degree )\r\n{\r\n\tfor( int i = 0; i <= res_degree; i++ )\r\n\t\t/* works with this line: */ // p1.a[ i ] = -( p2.a[ i ] - p1.a[ i ] );\r\n\t\tp1.a[ i ] = p1.a[ i ] - p2.a[ i ];\r\n\t\t\r\n\treturn p1;\r\n}\r\n\r\npolynomial mult( polynomial p1, polynomial p2, int res_degree )\r\n{\r\n\tpolynomial res = p1;\r\n\tfor( int i = 0; i <= res_degree; i++ )\r\n\t{\r\n\t\tres.a[ i ] = 0.0;\r\n\t\tfor( int j = 0; j <= i; j++ )\r\n\t\t\tres.a[ i ] += p1.a[ j ] * p2.a[ i - j ];\r\n\t}\r\n\treturn res;\r\n}\r\n\r\npolynomial neg( polynomial p, int res_degree )\r\n{\r\n\tfor( int i = 0; i <= res_degree; i++ )\r\n\t\tp.a[ i ] = -p.a[ i ];\r\n\treturn p;\r\n}\r\n/*\r\n// in Theorie schneller .. in Praxis bei kleinen Potenzen nicht ;-)\r\n// beruht auf Idee: a^n = (a^(n/2))^2\r\npolynomial power( polynomial p, int exp, int degree )\r\n{\r\n\tpolynomial result = create_poly_0( 1.0 );\r\n\r\n\tif( exp != 0 )\r\n\t{\r\n\t\tpolynomial y = p;\r\n\t\tint n = exp;\r\n\t\tint m = exp;\r\n\t\tfor( int i = 0; i < int( log2( float( exp ) ) ); i++ )\r\n\t\t{\r\n\t\t\tm = m / 2;\r\n\t\t\tdegree = degree + degree;\r\n\t\t\tif( n > 2 * m )\r\n\t\t\t\tresult = mult( result, y, degree );\r\n\t\t\ty = mult( y, y, degree );\r\n\t\t\tn = m;\r\n\t\t}\r\n\t\tresult = mult( result, y, degree );\r\n\t}\r\n\treturn result;\r\n}\r\n*/\r\npolynomial power( polynomial p, int exp, int degree )\r\n{\r\n\tpolynomial res = create_poly_0( 1.0 );\r\n\tfor( int res_degree = degree; res_degree < degree * exp + 1; res_degree += degree )\r\n\t\tres = mult( res, p, res_degree );\r\n\treturn res;\r\n}\r\n\r\npolynomial power_1( polynomial p, int exp )\r\n{\r\n//\treturn power( p, exp, 1 );\r\n\r\n\t// compute powers of p.a[ 0 ] and p.a[ 1 ]\r\n\tfloat a0 = p.a[ 0 ];\r\n\tfloat a1 = p.a[ 1 ];\r\n\tfloat powers_0[ SIZE ];\r\n\tfloat powers_1[ SIZE ];\r\n\tpowers_0[ 0 ] = 1.0;\r\n\tpowers_0[ 1 ] = a0;\r\n\tpowers_1[ 0 ] = 1.0;\r\n\tpowers_1[ 1 ] = a1;\r\n\tfor( int i = 2; i <= exp; i++ )\r\n\t{\r\n\t\tpowers_0[ i ] = powers_0[ i - 1 ] * a0;\r\n\t\tpowers_1[ i ] = powers_1[ i - 1 ] * a1;\r\n\t}\r\n\t\r\n\t// compute coefficients of polynomials by binomial expansion\r\n\tpolynomial res = create_poly_0( 0.0 );\r\n\tint a1_exp = exp;\r\n\tint a0_exp = 0;\r\n\tint bin_coeff = 1;\r\n\tfor( int deg = exp; deg >= 0; deg-- )\r\n\t{\r\n\t\tres.a[ deg ] = float( bin_coeff ) * powers_1[ a1_exp ] * powers_0[ a0_exp ];\r\n\t\ta0_exp++;\r\n\t\tbin_coeff = ( bin_coeff * a1_exp ) / a0_exp;\r\n\t\ta1_exp--;\r\n\t}\r\n\treturn res;\r\n}\r\n#endif\r\n\r\n// Ersatz für fehlerhafte NVidia-pow-Funktion ...\r\nfloat power( float base, int exp )\r\n{\r\n\tfloat res = 1.0;\r\n\tfor( int i = 0; i < exp; i++ )\r\n\t\tres *= base;\r\n\treturn res;\r\n}\r\n\r\n/**\r\n * methods, that operate with that algebraic function\r\n */\r\n#ifdef METHOD_DESCARTES\r\n#extension GL_EXT_gpu_shader4 : enable\r\nfloat epsilon = 0.0001;\r\nstruct roots\r\n{\r\n\tfloat x[ DEGREE + 2 ];\r\n\tbool valid[ DEGREE + 2 ];\r\n};\r\n\r\nfloat eval_p( const in polynomial p, float x )\r\n{\r\n\tfloat fx = p.a[ SIZE - 1 ];\r\n\tfor( int i = SIZE - 2; i >= 0; i-- )\r\n\t\tfx = fx * x + p.a[ i ];\r\n\treturn fx;\r\n}\r\n\r\nfloat bisect( const in polynomial p, float lowerBound, float upperBound )\r\n{\r\n\tfloat center = lowerBound;\r\n\tfloat old_center = upperBound;\r\n\tfloat fl = eval_p( p, lowerBound );\r\n\tfloat fu = eval_p( p, upperBound );\r\n\r\n\twhile( abs( upperBound - lowerBound ) > epsilon )\r\n\t{\r\n\t\told_center = center;\r\n\t\tcenter = 0.5 * ( lowerBound + upperBound );\r\n\t\tfloat fc = eval_p( p, center );\r" ) + string( "\n\t\t\r\n\t\tif( fc * fl < 0.0 )\r\n\t\t{\r\n\t\t\tupperBound = center;\r\n\t\t\tfu = fc;\r\n\t\t}\r\n\t\telse if( fc == 0.0 )\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tlowerBound = center;\r\n\t\t\tfl = fc;\r\n\t\t}\r\n\t}\r\n\treturn ( upperBound + lowerBound ) * 0.5;\r\n}\r\n/*\r\nint stretchShiftDescartesRuleOfSignReverseShift1( polynomial p, float scale, float shift, inout polynomial tmpCoeffs )\r\n{\r\n\tfloat multiplier = 1.0;//pow( scale, -float( DEGREE ) );\r\n\tfor( int i = 0; i < SIZE; i++ )\r\n\t{\r\n\t\ttmpCoeffs.a[ SIZE - 1 - i ] = multiplier * p.a[ i ];\r\n\t\tmultiplier *= scale;\r\n\t}\r\n\tfor( int i = 1; i <= SIZE; i++ )\r\n\t\tfor( int j = SIZE - 2; j >= i - 1; j-- )\r\n\t\t\ttmpCoeffs.a[ SIZE - 1 - j ] = tmpCoeffs.a[ SIZE - 1 - j ] + shift * tmpCoeffs.a[ SIZE - 1 - ( j + 1 ) ];    \r\n\t\r\n\tint signChanges = 0;\r\n\t\r\n\tfloat lastNonZeroCoeff = 0.0;\r\n\tfor( int i = 1; i <= SIZE; i++ )\r\n\t{\r\n\t\tfor( int j = SIZE - 2; j >= i - 1; j-- )\r\n\t\t\ttmpCoeffs.a[ j ] = tmpCoeffs.a[ j ] + tmpCoeffs.a[ j + 1 ];\r\n\t\tif( tmpCoeffs.a[ i - 1 ] != 0.0 )\r\n\t\t{\r\n\t\t\tif( tmpCoeffs.a[ i - 1 ] * lastNonZeroCoeff < 0.0 )\r\n\t\t\t\tsignChanges++;\r\n\t\t\tif( signChanges > 1 )\r\n\t\t\t\treturn signChanges;\r\n\t\t\tlastNonZeroCoeff = tmpCoeffs.a[ i - 1 ];\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn signChanges;\r\n}\r\n\r\npolynomial stretchNormalize0_5( polynomial p )\r\n{\r\n\tpolynomial result;\r\n\tresult.a[ SIZE - 1 ] = p.a[ SIZE - 1 ];\r\n\tfloat multiplier = 2.0;\r\n\tfor( int i = SIZE - 2; i >= 0; i-- )\r\n\t{\r\n\t\tresult.a[ i ] = p.a[ i ] * multiplier;\r\n\t\tmultiplier *= 2.0;\r\n\t}\r\n\t\r\n\treturn result;\r\n}\r\n\r\npolynomial shift1( polynomial p )\r\n{\r\n\tfor( int i = 1; i <= SIZE; i++ )\r\n\t\tfor( int j = SIZE - 2; j >= i - 1; j-- )\r\n\t\t\tp.a[ j ] = p.a[ j ] + p.a[ j + 1 ];\r\n\treturn p;\r\n}\r\n\r\nint descartesRuleOfSignReverseShift1( polynomial p )\r\n{\r\n\tint signChanges = 0;\r\n\tfloat[ SIZE ] hornerCoeffs;\r\n\tfor( int i = 0; i < SIZE; i++ )\r\n\t\thornerCoeffs[ i ] = p.a[ SIZE - i - 1 ];\r\n\t\r\n\tfloat lastNonZeroCoeff = 0.0;\r\n\tfor( int i = 1; i <= SIZE; i++ )\r\n\t{\r\n\t\tfor( int j = SIZE - 2; j >= i - 1; j-- )\r\n\t\t\thornerCoeffs[ j ] = hornerCoeffs[ j ] + hornerCoeffs[ j + 1 ];\r\n\t\tif( hornerCoeffs[ i - 1 ] != 0.0 )\r\n\t\t{\r\n\t\t\tif( hornerCoeffs[ i - 1 ] * lastNonZeroCoeff < 0.0 )\r\n\t\t\t\tsignChanges++;\r\n\t\t\tif( signChanges > 1 )\r\n\t\t\t\treturn signChanges;\r\n\t\t\tlastNonZeroCoeff = hornerCoeffs[ i - 1 ];\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn signChanges;\r\n}\r\n\r\npolynomial stretchShift( polynomial p, float scale, float shift )\r\n{\r\n\tpolynomial result;\r\n\tfloat multiplier = 1.0;\r\n\tfor( int i = 0; i < SIZE; i++ )\r\n\t{\r\n\t\tresult.a[ i ] = multiplier * p.a[ i ];\r\n\t\tmultiplier *= scale;\r\n\t}\r\n\tfor( int i = 1; i <= SIZE; i++ )\r\n\t\tfor( int j = SIZE - 2; j >= i - 1; j-- )\r\n\t\t\tresult.a[ j ] = result.a[ j ] + shift * result.a[ j + 1 ];    \r\n\treturn result;\r\n}\r\n\r\npolynomial stretch( polynomial p, float scale )\r\n{\r\n\tpolynomial result;\r\n\tfloat multiplier = pow( scale, -0.5 * float( DEGREE ) );\r\n\tfor( int i = 0; i < SIZE; i++ )\r\n\t{\r\n\t\tresult.a[ i ] = multiplier * p.a[ i ];\r\n\t\tmultiplier *= scale;\r\n\t}\r\n\treturn result;\r\n}\r\n\r\npolynomial shift( polynomial p, float shift )\r\n{\r\n\tpolynomial result;\r\n\tfor( int i = 0; i < SIZE; i++ )\r\n\t\tresult.a[ i ] = p.a[ i ];\r\n\tfor( int i = 1; i <= SIZE; i++ )\r\n\t\tfor( int j = SIZE - 2; j >= i - 1; j-- )\r\n\t\t\tresult.a[ j ] = result.a[ j ] + shift * result.a[ j + 1 ];    \r\n\treturn result;\r\n}\r\n*/\r\n\r\nint shiftStretchDescartesRuleOfSignReverseShift1( in polynomial p, float shift, float scale, inout polynomial tmpCoeffs )\r\n{\r\n\tfor( int i = 0; i < SIZE; i++ )\r\n\t\ttmpCoeffs.a[ SIZE - 1 - i ] = p.a[ i ];\r\n\t\r\n\tfor( int i = 1; i <= SIZE; i++ )\r\n\t\tfor( int j = SIZE - 2; j >= i - 1; j-- )\r\n\t\t\ttmpCoeffs.a[ SIZE - 1 - j ] = tmpCoeffs.a[ SIZE - 1 - j ] + shift * tmpCoeffs.a[ SIZE - 1 - ( j +" ) + string( " 1 ) ];    \r\n\t\r\n\tfloat multiplier = 1.0;\r\n\tfor( int i = 0; i < SIZE; i++ )\r\n\t\tmultiplier *= 1.0 / scale;\r\n\tfor( int i = 0; i < SIZE; i++ )\r\n\t{\r\n\t\ttmpCoeffs.a[ SIZE - 1 - i ] = multiplier * tmpCoeffs.a[ SIZE - 1 - i ];\r\n\t\tmultiplier *= scale;\r\n\t}\r\n\t\r\n\tif( tmpCoeffs.a[ SIZE - 1 ] == 0.0 )\r\n\t\treturn -1;\r\n\r\n\tint signChanges = 0;\r\n\t\r\n\tfloat lastNonZeroCoeff = 0.0;\r\n\tfor( int i = 1; i <= SIZE; i++ )\r\n\t{\r\n\t\tfor( int j = SIZE - 2; j >= i - 1; j-- )\r\n\t\t\ttmpCoeffs.a[ j ] = tmpCoeffs.a[ j ] + tmpCoeffs.a[ j + 1 ];\r\n\t\tif( tmpCoeffs.a[ i - 1 ] != 0.0 )\r\n\t\t{\r\n\t\t\tif( tmpCoeffs.a[ i - 1 ] * lastNonZeroCoeff < 0.0 )\r\n\t\t\t\tsignChanges++;\r\n\t\t\tif( signChanges > 1 )\r\n\t\t\t\treturn signChanges;\r\n\t\t\tlastNonZeroCoeff = tmpCoeffs.a[ i - 1 ];\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn signChanges;\r\n}\r\n\r\nfloat findSmallestPositveRootBelow( in polynomial p, const float upperBound, inout polynomial tmp )\r\n{\r\n\tif( shiftStretchDescartesRuleOfSignReverseShift1( p, 0.0, upperBound, tmp ) > 0 )\r\n\t{\r\n\t\tfloat size = 0.5;\r\n\t\tint id = 0;\r\n\t\twhile( size < 1.0 )\r\n\t\t{\r\n\t\t\tfloat scale = upperBound * size;\r\n\t\t\tint v = shiftStretchDescartesRuleOfSignReverseShift1( p, scale * float( id ), scale, tmp );\r\n\t\t\t\r\n\t\t\tif( v > 1 )\r\n\t\t\t{\r\n\t\t\t\t// go deeper on left side\r\n\t\t\t\tid *= 2;\r\n\t\t\t\tsize /= 2.0;\r\n\t\t\t}\r\n\t\t\telse if( v == 0 )\r\n\t\t\t{\r\n\t\t\t\t// go right\r\n\t\t\t\twhile( id % 2 == 1 )\r\n\t\t\t\t{\r\n\t\t\t\t\tid /= 2;\r\n\t\t\t\t\tsize *= 2.0;\r\n\t\t\t\t}\r\n\t\t\t\tid++;\r\n\t\t\t}\r\n\t\t\telse if( v == 1 )\r\n\t\t\t{\r\n\t\t\t\treturn bisect( p, scale * float( id ), scale * float( id + 1 ) );\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn scale * float( id );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn upperBound + 1.0;\r\n}\r\n\r\n/**\r\n * uses nearly the same algorithm as for positive roots:\r\n *  1. transforms x |-> -x (the new task is to find the largest positive root below -lowerBound)\r\n *  2. use bisection as in findSmallestPositveRootBelow, but start from the upper bound (=-lowerBound) of the search interval\r\n */\r\nfloat findSmallestNegativeRootAbove( in polynomial p, const float lowerBound, inout polynomial tmp )\r\n{\r\n\tfor( int i = 0; i < SIZE; i++ )\r\n\t\tif( i % 2 == 1 )\r\n\t\t\tp.a[ i ] = -p.a[ i ];\r\n\r\n\tfloat upperBound = -lowerBound;\r\n\tif( shiftStretchDescartesRuleOfSignReverseShift1( p, 0.0, upperBound, tmp ) > 0 )\r\n\t{\r\n\t\tfloat size = 0.5;\r\n\t\tint id = 0;\r\n\t\twhile( size < 1.0 )\r\n\t\t{\r\n\t\t\tfloat intervalStart = upperBound * ( 1.0 - size * float( id + 1 ) );\r\n\t\t\tint v = shiftStretchDescartesRuleOfSignReverseShift1( p, intervalStart, size * upperBound, tmp );\r\n\t\t\t\r\n\t\t\tif( v > 1 )\r\n\t\t\t{\r\n\t\t\t\t// go deeper on left side\r\n\t\t\t\tid *= 2;\r\n\t\t\t\tsize /= 2.0;\r\n\t\t\t}\r\n\t\t\telse if( v == 0 )\r\n\t\t\t{\r\n\t\t\t\t// go right\r\n\t\t\t\twhile( id % 2 == 1 )\r\n\t\t\t\t{\r\n\t\t\t\t\tid /= 2;\r\n\t\t\t\t\tsize *= 2.0;\r\n\t\t\t\t}\r\n\t\t\t\tid++;\r\n\t\t\t}\r\n\t\t\telse if( v == 1 )\r\n\t\t\t{\r\n\t\t\t\treturn -bisect( p, intervalStart, intervalStart + upperBound * size );\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn intervalStart;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn lowerBound - 1.0;\r\n}\r\n\r\nfloat findFirstRootIn( in polynomial p, float lowerBound, float upperBound )\r\n{\r\n\tpolynomial tmp;\r\n\tif( lowerBound < 0.0 )\r\n\t{\r\n\t\tfloat root = findSmallestNegativeRootAbove( p, lowerBound, tmp );\r\n\t\tif( root >= lowerBound )\r\n\t\t\treturn root;\r\n\t}\r\n\tif( p.a[ 0 ] == 0.0 )\r\n\t\treturn 0.0;\r\n\tif( upperBound > 0.0 )\r\n\t{\r\n\t\treturn findSmallestPositveRootBelow( p, upperBound, tmp );\r\n\t}\r\n\treturn lowerBound - 1.0;\r\n}\r\n\r\nroots solve( in polynomial p, const in vec2 trace_interval )\r\n{\r\n\tfloat intervalSize = trace_interval[ 1 ] - trace_interval[ 0 ];\r\n\t\r\n\t// init result array\r\n\troots res;\r\n\tres.x[ 0 ] = trace_interval[ 0 ];\r\n\tres.valid[ 0 ] = fals" ) + string( "e;\r\n\tfor( int i = 1; i < DEGREE + 2; i++ )\r\n\t{\r\n\t\tres.x[ i ] = trace_interval[ 1 ];\r\n\t\tres.valid[ i ] = false;\r\n\t}\r\n\r\n\tres.x[ 1 ] = findFirstRootIn( p, trace_interval[ 0 ], trace_interval[ 1 ] );\r\n\tif( res.x[ 1 ] >= trace_interval[ 0 ] && res.x[ 1 ] <= trace_interval[ 1 ] )\r\n\t\tres.valid[ 1 ] = true;\r\n\t\r\n\treturn res;\r\n}\r\n#endif\r\n\r\n#ifdef METHOD_STURM\r\nfloat epsilon = 0.0001;\r\nfloat sturm_chain[ ( SIZE * ( SIZE + 1 ) ) / 2 ];\r\n\r\nint sc_index( int f_index, int c_index )\r\n{\r\n\r\n\t//~ int result = 0;\r\n\t//~ for( int i = DEGREE; i > f_index; i-- )\r\n\t\t//~ result += i;\r\n\t//~ return result + c_index;\r\n\r\n\treturn ( SIZE * ( SIZE + 1 ) ) / 2 - 1 - ( ( f_index + 1 ) * ( f_index + 2 ) ) / 2 + c_index;\r\n}\r\n\r\nfloat eval_f( float where )\r\n{\r\n\tfloat res = 0.0;\r\n\tfor( int i = DEGREE; i >= 0; i-- )\r\n\t\tres = sturm_chain[ sc_index( DEGREE, i ) ] + where * res;\r\n\treturn res;\r\n}\r\n\r\nfloat bisection( float x0, float x1 )\r\n{\r\n\tfloat f0 = eval_f( x0 );\r\n\tfloat f1 = eval_f( x1 );\r\n\tfloat x2 = x0;\r\n\twhile( abs( x0 - x1 ) > epsilon )\r\n\t{\r\n\t\tx2 = 0.5 * ( x0 + x1 );\r\n\t\tfloat f2 = eval_f( x2 );\r\n\t\tif( f2 * f0 < 0.0 )\r\n\t\t{\r\n\t\t\tx1 = x2;\r\n\t\t\tf1 = f2;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tx0 = x2;\r\n\t\t\tf0 = f2;\r\n\t\t}\r\n\t}\r\n\treturn x2;\r\n}\r\n\r\nbool contains( const in vec2 interval, const in float value )\r\n{\r\n\treturn ( interval[ 0 ] < value && value < interval[ 1 ] ) || ( interval[ 0 ] > value && value > interval[ 1 ] );\r\n}\r\n\r\nvoid polynom_div( int dividend, int divisor, int remainder )\r\n{\r\n\t// copy dividend to be the current remainder\r\n\tint i;\r\n\tfor( i = 0; i <= dividend; i++ )\r\n\t\tsturm_chain[ sc_index( remainder, i )] = sturm_chain[ sc_index( dividend, i ) ];\r\n\r\n\tint degree_diff = dividend - divisor;\r\n\tfor( i = dividend; i >= divisor; i-- )\r\n\t{\r\n\t\t// calculate quotient of highest coefficient\r\n\t\tfloat quotient = sturm_chain[ sc_index( remainder, i ) ] / sturm_chain[ sc_index( divisor, divisor ) ];\r\n\t\t\r\n\t\t// after this step the highest coeff. of the old remainder is actually zero\r\n\t\t//sturm_chain[ remainder * SIZE + i ] = 0.0; // unnecessary calculation, because value is known\r\n\t\t\r\n\t\t// calculate new coeffs. of the remainder\r\n\t\tfor( int j = 0; j < divisor; j++ )\r\n\t\t\tsturm_chain[ sc_index( remainder, j + degree_diff ) ] = sturm_chain[ sc_index( remainder, j + degree_diff ) ] - sturm_chain[ sc_index( divisor, j ) ] * quotient;\r\n\r\n\t\tdegree_diff--;\r\n\t}\r\n}\r\n\r\nvoid construct_sturm_chain()\r\n{\r\n\t// calculate first derivate of f\r\n\tint i;\r\n\t//sturm_chain[ DEGREE - 1 ][ DEGREE ] = 0.0f;\r\n\tfor( i = 1; i <= DEGREE; i++ )\r\n\t\tsturm_chain[ sc_index( DEGREE - 1, i - 1 ) ] = float( i ) * sturm_chain[ sc_index( DEGREE, i ) ];// / ( DEGREE * sturm_chain[ DEGREE ][ DEGREE ] );\r\n\t\r\n\t// calculate sturm chain\r\n\tfor( i = DEGREE - 2; i >= 0; i-- )\r\n\t{\r\n\t\t// polynom division, which outputs the remainder to the sturm_chain-array\r\n\t\tpolynom_div( i + 2, i + 1, i );\r\n\t\t\r\n\t\t// flip the sign of the remainder and normalize polynom\r\n\t\tfor( int j = 0; j <= i; j++ )\r\n\t\t\tsturm_chain[ sc_index( i, j ) ] = -sturm_chain[ sc_index( i, j ) ];\r\n\t}\r\n}\r\n\r\nfloat f_sturm( int num, float t )\r\n{\r\n\tfloat res = 0.0;\r\n\tfor( int i = num; i >= 0; i-- )\r\n\t\tres = sturm_chain[ sc_index( num, i ) ] + t * res;\r\n\treturn res;\r\n}\r\n\r\nint sign_change( float t )\r\n{\r\n\tint sign_sum = 0;\r\n\tfloat last_sign, cur_sign;\r\n\t\r\n\t// #Vorzeichenwechsel an t berechnen\r\n\tlast_sign = sign( f_sturm( DEGREE, t ) );\r\n\r\n\tfor( int i = DEGREE - 1; i >= 0; i-- )\r\n\t{\r\n\t\tcur_sign = sign( f_sturm( i, t ) );\r\n\t\tsign_sum += ( last_sign != cur_sign ) ? 1 : 0;\r\n\t\tif( cur_sign != 0.0 )\r\n\t\t\tlast_sign = cur_sign;\r\n\t}\r\n\t\r\n\treturn sign_sum;\r\n}\r\n\r\nfloat bisection_sturm( float x0, float x1 )\r\n{\r\n\tfloat x2 = x0 - 1.0;\r\n\tint sign_change_0 = sign_change( x0 );\r\n\tint sign_ch" ) + string( "ange_1 = sign_change( x1 );\r\n\t\r\n\tif( sign_change_0 - sign_change_1 != 0 )\r\n\t{\r\n\t\t{\r\n\t\t\tfloat f0 = eval_f( x0 );\r\n\t\t\tfloat f1 = eval_f( x1 );\r\n\t\t\t\r\n\t\t\twhile( !( sign_change_0 - sign_change_1 == 1 && f0 * f1 < 0.0 ) )\r\n\t\t\t{\r\n\t\t\t\tx2 = 0.5 * ( x0 + x1 );\r\n\t\t\t\t\r\n\t\t\t\tint sign_change_2 = sign_change( x2 );\r\n\t\t\t\tfloat f2 = eval_f( x2 );\r\n\t\t\t\t\r\n\t\t\t\tif( sign_change_0 - sign_change_2 > 0 )\r\n\t\t\t\t{\r\n\t\t\t\t\t// there is a root in the first interval -> search in first\r\n\t\t\t\t\tx1 = x2;\r\n\t\t\t\t\tf1 = f2;\r\n\t\t\t\t\tsign_change_1 = sign_change_2;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// there is no root in the first interval -> search in second\r\n\t\t\t\t\tx0 = x2;\r\n\t\t\t\t\tf0 = f2;\r\n\t\t\t\t\tsign_change_0 = sign_change_2;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tx2 = bisection( x0, x1 );\r\n\t}\r\n\t\r\n\treturn x2;\r\n}\r\n\r\nstruct roots\r\n{\r\n\tfloat x[ DEGREE + 2 ];\r\n\tbool valid[ DEGREE + 2 ];\r\n};\r\n\r\nroots solve( const in polynomial p, const in vec2 trace_interval )\r\n{\r\n#if DEGREE > 1\r\n\t// fill\tsturm chain array\r\n\tfor( int i = 0; i < SIZE; i++ )\r\n\t\tsturm_chain[ sc_index( DEGREE, i ) ] = p.a[ i ];\r\n\tconstruct_sturm_chain();\r\n#endif\r\n\r\n\t// init result array\r\n\troots res;\r\n\tres.x[ 0 ] = trace_interval[ 0 ];\r\n\tres.valid[ 0 ] = false;\r\n\tfor( int i = 1; i < DEGREE + 2; i++ )\r\n\t{\r\n\t\tres.x[ i ] = trace_interval[ 1 ];\r\n\t\tres.valid[ i ] = false;\r\n\t}\r\n\r\n#if DEGREE > 1\r\n\t// apply sturm\'s algorithm\r\n\tres.x[ 1 ] = bisection_sturm( trace_interval[ 0 ], trace_interval[ 1 ] );\r\n#else\r\n\t// solve linear equation directly\r\n\tres.x[ 1 ] = -p.a[ 0 ] / p.a[ 1 ];\r\n#endif\r\n\tres.valid[ 1 ] = contains( trace_interval, res.x[ 1 ] );\r\n\r\n\treturn res;\r\n}\r\n#endif\r\n#ifdef METHOD_D_CHAIN\r\nfloat epsilon = 0.000001;\r\npolynomial derivatives[ DEGREE ];\r\n\r\nfloat eval_f( int which, float where )\r\n{\r\n\tfloat res = 0.0;\r\n\tfor( int i = DEGREE - which; i >= 0; i-- )\r\n\t\tres = derivatives[ which ].a[ i ] + where * res;\r\n\treturn res;\r\n}\r\n\r\nvoid calc_derivatives()\r\n{\r\n\tfor( int derivate = 1; derivate < DEGREE; derivate++ )\r\n\t\tfor( int j = 0; j <= DEGREE - derivate; j++ )\r\n\t\t\tderivatives[ derivate ].a[ j ] = float( j + 1 ) * derivatives[ derivate - 1 ].a[ j + 1 ];\r\n}\r\n\r\n#ifdef SUB_METHOD_BISECTION\r\nfloat bisection( int f_index, float x0, float f0, float x1, float f1 )\r\n{\r\n\tfloat x2 = x0;\r\n\twhile( abs( x0 - x1 ) > epsilon )\r\n\t{\r\n\t\tx2 = 0.5 * ( x0 + x1 );\r\n\t\tfloat f2 = eval_f( f_index, x2 );\r\n\t\tif( f2 * f0 < 0.0 )\r\n\t\t{\r\n\t\t\tx1 = x2;\r\n\t\t\tf1 = f2;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tx0 = x2;\r\n\t\t\tf0 = f2;\r\n\t\t}\r\n\t}\r\n\treturn x2;\r\n}\r\n#endif\r\n\r\n#ifdef SUB_METHOD_REGULA_FALSI\r\nfloat regula_falsi( int f_index, float x0, float f0, float x1, float f1 )\r\n{\r\n\tfloat x2 = x0;\r\n\twhile( abs( x0 - x1 ) > epsilon )\r\n\t{\r\n\t\tx2 =  x0 - f0 * ( x1 - x0 ) / ( f1 - f0 );\r\n\t\tfloat f2 = eval_f( f_index, x2 );\r\n\t\tif( f2 * f0 < 0.0 )\r\n\t\t{\r\n\t\t\tx1 = x2;\r\n\t\t\tf1 = f2;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tx0 = x2;\r\n\t\t\tf0 = f2;\r\n\t\t}\r\n\t}\r\n\treturn x2;\r\n}\r\n#endif\r\n\r\nstruct roots\r\n{\r\n\tfloat x[ DEGREE + 2 ];\r\n\tbool valid[ DEGREE + 2 ];\r\n};\r\n\r\nbool contains( const in vec2 interval, const in float value )\r\n{\r\n\treturn ( interval[ 0 ] < value && value < interval[ 1 ] ) || ( interval[ 0 ] > value && value > interval[ 1 ] );\r\n}\r\n\r\nvoid calc_roots( const in int derivate_num, const in roots read_from, inout roots write_to )\r\n{\r\n\t// for each root pair of the current derivate: look for roots of previous derivate\r\n\tfor( int interval_num = 0; interval_num < DEGREE + 2 - 1 - derivate_num; interval_num++ )\r\n\t{\r\n\t\twrite_to.x[ interval_num + 1 ] = write_to.x[ interval_num ];\r\n\t\twrite_to.valid[ interval_num + 1 ] = false;\r\n\t\t\r\n\t\tif( read_from.valid[ interval_num + 1 ] )\r\n\t\t{\r\n\t\t\tfloat f0 = eval_f( " ) + string( "derivate_num, read_from.x[ interval_num ] );\r\n\t\t\tfloat f1 = eval_f( derivate_num, read_from.x[ interval_num + 1 ] );\r\n\t\t\tif( write_to.valid[ interval_num + 1 ] = ( f0 * f1 < 0.0 ) )\r\n\t\t\t\t// there is one root in current interval and root finder will converge\r\n#ifdef SUB_METHOD_BISECTION\r\n\t\t\t\twrite_to.x[ interval_num + 1 ] = bisection( derivate_num, read_from.x[ interval_num ], f0, read_from.x[ interval_num + 1 ], f1 );\r\n#endif\r\n#ifdef SUB_METHOD_REGULA_FALSI\r\n\t\t\t\twrite_to.x[ interval_num + 1 ] = regula_falsi( derivate_num, read_from.x[ interval_num ], f0, read_from.x[ interval_num + 1 ], f1 );\r\n#endif\r\n\t\t}\r\n\t}\r\n\t\r\n\twrite_to.x[ DEGREE - derivate_num + 1 ] = read_from.x[ DEGREE - derivate_num + 1 ];\r\n\twrite_to.valid[ DEGREE - derivate_num + 1 ] = true;\r\n}\r\n\r\nroots solve( in polynomial p, const in vec2 trace_interval )\r\n{\r\n\t\r\n\t// copy coefficients in polynom array\r\n\tderivatives[ 0 ] = p;\r\n\t// fill derivatives array\r\n\tcalc_derivatives();\r\n\t\r\n\t// arrays of roots which are swaped after each iteration\r\n\troots read_from, write_to;\r\n\tread_from.x[ 0 ] = write_to.x[ 0 ] = trace_interval[ 0 ];\r\n\tread_from.valid[ 0 ] = write_to.valid[ 0 ] = true;\r\n\tread_from.x[ 1 ] = write_to.x[ 1 ] = trace_interval[ 0 ];\r\n\tread_from.valid[ 1 ] = write_to.valid[ 1 ] = false;\r\n\tread_from.x[ 2 ] = write_to.x[ 2 ] = trace_interval[ 1 ];\r\n\tread_from.valid[ 2 ] = write_to.valid[ 2 ] = true;\r\n\tfor( int i = 3; i < DEGREE + 2; i++ )\r\n\t{\r\n\t\tread_from.x[ i ] = write_to.x[ i ] = trace_interval[ 1 ];\r\n\t\tread_from.valid[ i ] = write_to.valid[ i ] = false;\r\n\t}\r\n\t\r\n\t// basic case: calculate root of degree 1 derivate\r\n\tfloat lin_root = -derivatives[ DEGREE - 1 ].a[ 0 ] / derivatives[ DEGREE - 1 ].a[ 1 ];\r\n\tif( contains( trace_interval, lin_root ) )\r\n\t{\r\n\t\tread_from.x[ 1 ] = lin_root;\r\n\t\tread_from.valid[ 1 ] = true;\r\n\t}\r\n\r\n#if DEGREE > 1\r\n\tfor( int i = DEGREE - 2; i >= 0; i-- )\r\n\t{\r\n\t\tcalc_roots( i, read_from, write_to );\r\n\t\t\r\n\t\t// copy result to the input buffer of the next iteration\r\n\t\tread_from = write_to;\r\n\t}\r\n#endif\r\n\t\t\r\n\treturn read_from;\r\n}\r\n#endif\r\n#ifdef METHOD_INTERVAL\r\npolynomial derivatives[ DEGREE + 1 ];\r\n\r\nfloat eval_f( int which, float where )\r\n{\r\n\tfloat res = 0.0;\r\n\tfor( int i = which; i >= 0; i-- )\r\n\t\tres = derivatives[ which ].a[ i ] + where * res;\r\n\treturn res;\r\n}\r\n\r\nvoid calc_derivatives()\r\n{\r\n\tfor( int derivate = DEGREE - 1; derivate >= 0; derivate-- )\r\n\t\tfor( int j = 0; j <= derivate; j++ )\r\n\t\t\tderivatives[ derivate ].a[ j ] = float( j + 1 ) * derivatives[ derivate + 1 ].a[ j + 1 ];\r\n}\r\n\r\n// interval operations\r\nvec2 mult_01( vec2 i ) { return vec2( min( 0.0, i[ 0 ] ), max( 0.0, i[ 1 ] ) ); }\r\nvec2 make_n11( float f ) { return vec2( min( -f, f ), max( -f, f ) ); }\r\n\r\n#ifdef SUB_METHOD_BISECTION\r\nfloat epsilon = 0.003;\r\nvec2 taylor_bound( vec2 i_x )\r\n{\r\n\t#if DEGREE == 1\r\n\t\tfloat f0 = eval_f( DEGREE, i_x[ 0 ] );\r\n\t\tfloat f1 = eval_f( DEGREE, i_x[ 1 ] );\r\n\t\t\r\n\t\treturn vec2( min( f0, f1 ), max( f0, f1 ) );\r\n\t#else\r\n\t\tfloat x_0 = ( i_x[ 0 ] + i_x[ 1 ] ) * 0.5;\r\n\t\tfloat x_1 = ( i_x[ 1 ] - i_x[ 0 ] ) * 0.5;\r\n\t\t\r\n\t\t#if DEGREE / 2 == SIZE / 2\r\n\t\t\t// base case\r\n\t\t\tvec2 bound = vec2( eval_f( 0, x_0 ) );\r\n\t\t\t// iterative variant of recursive taylor method\r\n\t\t\tfor( int derivate = 2; derivate <= DEGREE; derivate += 2 )\r\n\t\t\t\tbound = vec2( eval_f( derivate, x_0 ) ) + make_n11( x_1 * eval_f( derivate - 1, x_0 ) ) + ( 0.5 * x_1 * x_1 ) * mult_01( bound );\r\n\t\t#else\r\n\t\t\t// base case\r\n\t\t\tvec2 bound = vec2( eval_f( 1, x_0 ) ) + make_n11( x_1 * eval_f( 0, x_0 ) );\r\n\t\t\t// iterative variant of recursive taylor method\r\n\t\t\tfor( int derivate = 3; derivate <= DEGREE; derivate += 2 )\r\n\t\t\t\tbound = vec2( eval_f( derivate, x_0 ) ) + make_n11( x_1 * eval_f( derivate - 1, x_0 ) ) + ( 0.5 * x_1 * x_1 ) * mult_01( bound );\r\n\t\t#endif\r\n\t\tre" ) + string( "turn bound;\r\n\t#endif\r\n}\r\n\r\nfloat bisection_interval( float x0, float x1 )\r\n{\r\n\tfloat x_upper_bound = x1;\r\n\tfloat x2 = x1;\r\n\t\r\n\tvec2 bound = taylor_bound( vec2( x0, x1 ) );\r\n\twhile( ( bound[ 0 ] <= 0.0 && bound[ 1 ] >= 0.0 ) && x1 - x0 > epsilon && x0 < x_upper_bound )\r\n\t{\r\n\t\tx2 = 0.5 * ( x0 + x1 );\r\n\t\tbound = taylor_bound( vec2( x0, x2 ) );\r\n\t\t\r\n\t\tif( bound[ 0 ] <= 0.0 && bound[ 1 ] >= 0.0 )\r\n\t\t{\r\n\t\t\t// there is a root in the first interval -> search in first\r\n\t\t\tx1 = x2;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// there is no root in the first interval -> search in second\r\n\t\t\tx0 = x2;\r\n\t\t\tx1 = x_upper_bound;\r\n\t\t\tbound = taylor_bound( vec2( x0, x1 ) );\r\n\t\t}\r\n\t}\r\n\r\n\tif( !( bound[ 0 ] <= 0.0 && bound[ 1 ] >= 0.0 ) )\r\n\t\tx2 = x_upper_bound + 1.0;\r\n\t\r\n\treturn x2;\r\n}\r\n#endif\r\n\r\n#ifdef SUB_METHOD_SPHERE_TRACING\r\nfloat epsilon = 0.00001;\r\nvec2 taylor_bound_df( vec2 i_x )\r\n{\r\n\t#if DEGREE == 1\r\n\t\treturn vec2( eval_f( 0, 0.0 ) );\r\n\t#else\r\n\t\t#define DF_DEGREE ( DEGREE - 1 )\r\n\t\t#define DF_SIZE ( SIZE - 1 )\r\n\t\t\t#if DF_DEGREE == 1\r\n\t\t\t\tfloat f0 = eval_f( DF_DEGREE, i_x[ 0 ] );\r\n\t\t\t\tfloat f1 = eval_f( DF_DEGREE, i_x[ 1 ] );\r\n\t\t\t\t\r\n\t\t\t\treturn vec2( min( f0, f1 ), max( f0, f1 ) );\r\n\t\t\t#else\r\n\t\t\t\tfloat x_0 = ( i_x[ 0 ] + i_x[ 1 ] ) * 0.5;\r\n\t\t\t\tfloat x_1 = ( i_x[ 1 ] - i_x[ 0 ] ) * 0.5;\r\n\t\t\t\t\r\n\t\t\t\t#if DF_DEGREE / 2 == DF_SIZE / 2\r\n\t\t\t\t\t// base case\r\n\t\t\t\t\tvec2 bound = vec2( eval_f( 0, x_0 ) );\r\n\t\t\t\t\t// iterative variant of recursive taylor method\r\n\t\t\t\t\tfor( int derivate = 2; derivate <= DF_DEGREE; derivate += 2 )\r\n\t\t\t\t\t\tbound = vec2( eval_f( derivate, x_0 ) ) + make_n11( x_1 * eval_f( derivate - 1, x_0 ) ) + ( 0.5 * x_1 * x_1 ) * mult_01( bound );\r\n\t\t\t\t#else\r\n\t\t\t\t\t// base case\r\n\t\t\t\t\tvec2 bound = vec2( eval_f( 1, x_0 ) ) + make_n11( x_1 * eval_f( 0, x_0 ) );\r\n\t\t\t\t\t// iterative variant of recursive taylor method\r\n\t\t\t\t\tfor( int derivate = 3; derivate <= DF_DEGREE; derivate += 2 )\r\n\t\t\t\t\t\tbound = vec2( eval_f( derivate, x_0 ) ) + make_n11( x_1 * eval_f( derivate - 1, x_0 ) ) + ( 0.5 * x_1 * x_1 ) * mult_01( bound );\r\n\t\t\t\t#endif\r\n\t\t\t\treturn bound;\r\n\t\t\t#endif\r\n\t\t#undef DF_SIZE\r\n\t\t#undef DF_DEGREE\r\n\t#endif\r\n}\r\n\r\nfloat sphere_tracing( float x0, float x1 )\r\n{\r\n\tvec2 df_bound = abs( taylor_bound_df( vec2( x0, x1 ) ) );\r\n\tfloat lipschitz = max( df_bound[ 0 ], df_bound[ 1 ] );\r\n\t\r\n\tfloat x = x0;\r\n\tfloat last_x = x - 1.0;\r\n\tfloat f = abs( eval_f( DEGREE, x ) );\r\n\twhile( x - last_x > epsilon && x < x1 )\r\n\t{\r\n\t\tlast_x = x;\r\n\t\tx = x + f / lipschitz;\r\n\t\tf = abs( eval_f( DEGREE, x ) );\r\n\t\t\r\n\t\tdf_bound = abs( taylor_bound_df( vec2( x, x1 ) ) );\r\n\t\tlipschitz = max( df_bound[ 0 ], df_bound[ 1 ] );\r\n\t}\r\n\treturn x;\r\n}\r\n#endif\r\n\r\nstruct roots\r\n{\r\n\tfloat x[ DEGREE + 2 ];\r\n\tbool valid[ DEGREE + 2 ];\r\n};\r\n\r\nbool contains( const in vec2 interval, const in float value )\r\n{\r\n\treturn ( interval[ 0 ] < value && value < interval[ 1 ] ) || ( interval[ 0 ] > value && value > interval[ 1 ] );\r\n}\r\n\r\nroots solve( const in polynomial p, const in vec2 trace_interval )\r\n{\r\n\t// copy coefficients in polynom array\r\n\tderivatives[ DEGREE ] = p;\r\n\t// fill derivatives array\r\n\tcalc_derivatives();\r\n\t\r\n\t// init result array\r\n\troots res;\r\n\tres.x[ 0 ] = trace_interval[ 0 ];\r\n\tres.valid[ 0 ] = false;\r\n\tfor( int i = 1; i < DEGREE + 2; i++ )\r\n\t{\r\n\t\tres.x[ i ] = trace_interval[ 1 ];\r\n\t\tres.valid[ i ] = false;\r\n\t}\r\n\r\n\t// apply interval algorithm\r\n\t#ifdef SUB_METHOD_BISECTION\r\n\t\tres.x[ 1 ] = bisection_interval( trace_interval[ 0 ], trace_interval[ 1 ] );\r\n\t#endif\r\n\t#ifdef SUB_METHOD_SPHERE_TRACING\r\n\t\tres.x[ 1 ] = sphere_tracing( trace_interval[ 0 ], trace_interval[ 1 ] );\r\n\t#endif\r\n\tres.valid[ 1 ] = contains( trace_interval, res.x[ 1 ] );\r\n\t\r\n\tr" ) + string( "eturn res;\r\n}\r\n#endif\r\n#ifdef METHOD_LAGUERRE\r\nfloat epsilon = 0.0001;\r\nstruct complex\r\n{\r\n\tfloat re;\r\n\tfloat im;\r\n};\r\n\r\ncomplex conj( complex z ) { z.im = -z.im; return z; }\r\nfloat sabs( complex z ) { return abs( z.re ) + abs( z.im ); }\r\nfloat magnitude( complex z ) { return sqrt( z.re * z.re + z.im * z.im ); }\r\n\r\ncomplex add( float x, complex z ) { z.re = x + z.re; return z; }\r\ncomplex add( complex z, float x ) { z.re = z.re + x; return z; }\r\ncomplex add( complex z1, complex z2 ) { return complex( z1.re + z2.re, z1.im + z2.im ); }\r\n\r\ncomplex sub( float x, complex z ) { z.re = x - z.re; return z; }\r\ncomplex sub( complex z, float x ) { z.re = z.re - x; return z; }\r\ncomplex sub( complex z1, complex z2 ) { return complex( z1.re - z2.re, z1.im - z2.im ); }\r\n\r\ncomplex mult( float x, complex z ) { return complex( x * z.re, x * z.im ); }\r\ncomplex mult( complex z, float x ) { return complex( x * z.re, x * z.im ); }\r\ncomplex mult( complex z1, complex z2 ) { return complex( z1.re * z2.re - z1.im * z2.im, z1.re * z2.im + z1.im * z2.re ); }\r\n\r\ncomplex div( complex z, float x ) { return complex( z.re / x, z.im / x ); }\r\ncomplex div( float x, complex z ) { float tmp = z.re * z.re + z.im * z.im; return complex( ( x * z.re ) / tmp, -( x * z.im ) / tmp ); }\r\ncomplex div( complex z1, complex z2 ) { float tmp = z2.re * z2.re + z2.im * z2.im; return complex( ( z1.re * z2.re + z1.im * z2.im ) / tmp, ( z1.im * z2.re - z1.re * z2.im ) / tmp ); }\r\n\r\ncomplex square( complex z ) { return complex( z.re * z.re - z.im * z.im, 2.0 * z.re * z.im ); }\r\n\r\ncomplex complex_sqrt( complex z )\r\n{\r\n\tcomplex c;\r\n\tif( ( z.re == 0.0 ) && ( z.im == 0.0 ) )\r\n\t{\r\n\t\tc = z;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfloat x, y, w, r;\r\n\t\tx = abs( z.re );\r\n\t\ty = abs( z.im );\r\n\t\tif( x >= y )\r\n\t\t{\r\n\t\t\tr = y / x;\r\n\t\t\tw = sqrt( x ) * sqrt( 0.5 * ( 1.0 + sqrt( 1.0 + r * r ) ) );\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tr = x / y;\r\n\t\t\tw = sqrt( y ) * sqrt( 0.5 * ( r + sqrt( 1.0 + r * r ) ) );\r\n\t\t}\r\n\t\tif( z.re >= 0.0 )\r\n\t\t{\r\n\t\t\tc.re = w;\r\n\t\t\tc.im = z.im / ( 2.0 * w );\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif( z.im >= 0.0 ) \r\n\t\t\t\tc.im = w;\r\n\t\t\telse\r\n\t\t\t\tc.im = -w;\r\n\t\t\tc.re = z.im / ( 2.0 * c.im );\r\n\t\t}\r\n\t}\r\n\treturn c;\r\n}\r\n\r\nfloat c[ SIZE ];\r\n\r\ncomplex laguerre( complex x, int degree )\r\n{\r\n\tcomplex a = complex( 1.0, 0.0 );\r\n\tfloat f_degree = float( degree );\r\n\tint iterations = 0;\r\n\t\r\n\tcomplex f, df, ddf;\r\n\tbool root_found = false;\r\n\twhile( !root_found )\r\n\t{\r\n\t\tx = sub( x, a );\r\n\r\n\t\tf = complex( c[ degree ], 0.0 );\r\n\t\tdf = complex( 0.0, 0.0 );\r\n\t\tddf = complex( 0.0, 0.0 );\r\n\t\t\r\n\t\t// efficient computation of f, first derivate of f and second derivate of f \r\n\t\tfor( int i = degree - 1; i >= 0; i-- )\r\n\t\t{\r\n\t\t\tddf = add( mult( x, ddf ), df );\r\n\t\t\tdf = add( mult( x, df ), f );\r\n\t\t\tf = add( mult( x, f ), c[ i ] );\r\n\t\t}\r\n\t\t\r\n\t\t// eigentlich würde es reichen, wenn diese Bedingung in der while-Schleife geprüft wird,\r\n\t\t// aber dann klappt\'s nicht mehr -> compiler bug\r\n\t\tif( sabs( f ) != 0.0 && magnitude( a ) > 0.00001 * magnitude( x ) )\r\n\t\t{\r\n\t\t\tcomplex G = ( div( df, f ) );\r\n\t\t\tcomplex G2 = square( G );\r\n\t\t\tcomplex H = ( sub( G2, div( ddf, f ) ) );\r\n\t\t\t\r\n\t\t\tcomplex sqrt_term = complex_sqrt( mult( f_degree - 1.0, sub( mult( f_degree, H ), G2 ) ) );\r\n\t\t\tcomplex denom1 = add( G, sqrt_term );\r\n\t\t\tcomplex denom2 = sub( G, sqrt_term );\r\n\t\t\t\r\n\t\t\tif( magnitude( denom1 ) > magnitude( denom2 ) )\r\n\t\t\t\ta = div( f_degree, denom1 );\r\n\t\t\telse\r\n\t\t\t\ta = div( f_degree, denom2 );\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\troot_found = true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn x;\r\n}\r\n\r\nvoid bubble_sort( inout float a[ DEGREE + 2 ] )\r\n{\r\n\tfor( int i = 1; i < DEGREE + 2; i++ )\r\n\t{\r\n\t\tfor( int j = 0; j < DEGREE + 2 - i; j++ )\r\n\t\t{\r\n\t\t\tif( a[ j ] > a[ j + 1 ] )\r\n\t\t\t{" ) + string( "\r\n\t\t\t\tfloat temp = a[ j ];\r\n\t\t\t\ta[ j ] = a[ j + 1 ];\r\n\t\t\t\ta[ j + 1 ] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstruct roots\r\n{\r\n\tfloat x[ DEGREE + 2 ];\r\n\tbool valid[ DEGREE + 2 ];\r\n};\r\n\r\nbool contains( const in vec2 interval, const in float value )\r\n{\r\n\treturn interval[ 0 ] < value && value < interval[ 1 ];\r\n}\r\n\r\nfloat solve_linear() { return -c[ 0 ] / c[ 1 ]; }\r\nvoid solve_quadric( out float x1, out float x2, const in vec2 trace_interval )\r\n{\r\n\tfloat diskriminante = c[ 1 ] * c[ 1 ] - 4.0 * c[ 2 ] * c[ 0 ];\r\n\tif( diskriminante >= 0.0 )\r\n\t{\r\n\t\tfloat q = -0.5 * ( c[ 1 ] + sign( c[ 1 ] ) * sqrt( diskriminante ) );\r\n\t\tx1 = q / c[ 2 ];\r\n\t\tx2 = c[ 0 ] / q;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tx1 = x2 = trace_interval[ 0 ] - 1.0;\r\n\t}\r\n}\r\n\r\nroots solve( const in polynomial p, const in vec2 trace_interval )\r\n{\r\n\t// create complex coefficient array from real coefficient array\r\n\tfor( int i = 0; i < SIZE; i++ )\r\n\t\tc[ i ] = p.a[ i ];\r\n\t\r\n\t// init result array\r\n\troots res;\r\n\tres.x[ 0 ] = trace_interval[ 0 ];\r\n\tres.valid[ 0 ] = false;\r\n\tres.x[ DEGREE + 1 ] = trace_interval[ 1 ];\t\r\n\tres.valid[ DEGREE + 1 ] = false;\r\n\r\n\t// solve individual root successively\r\n\tcomplex initial = complex( 0.5 * ( trace_interval[ 0 ] + trace_interval[ 1 ] ), 0.0 );\r\n\tbool skip_next = false;\r\n\tfor( int i = 0; i < DEGREE; i++ )\r\n\t{\r\n\t\tif( skip_next )\r\n\t\t{\r\n\t\t\tskip_next = false;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif( DEGREE - i == 1 )\r\n\t\t\t{\r\n\t\t\t\tres.x[ i + 1 ] = solve_linear();\r\n\t\t\t}\r\n\t\t\telse if( DEGREE - i == 2 )\r\n\t\t\t{\r\n\t\t\t\tsolve_quadric( res.x[ i + 1 ], res.x[ i + 2 ], trace_interval );\r\n\t\t\t\tskip_next = true;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcomplex root = laguerre( initial, DEGREE - i );\r\n\t\t\r\n\t\t\t\tif( abs( root.im ) < 1e-04 * abs( root.re ) )\r\n\t\t\t\t{\r\n\t\t\t\t\t// deflate real root \'root.re\'\r\n\t\t\t\t\tres.x[ i + 1 ] = root.re;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfloat oldc;\r\n\t\t\t\t\tfloat newc = c[ DEGREE - i ];\r\n\t\t\t\t\tfor( int j = DEGREE - i - 1; j > -1; j-- )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toldc = c[ j ];\r\n\t\t\t\t\t\tc[ j ] = newc;\r\n\t\t\t\t\t\tnewc = oldc + newc * root.re;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// deflate complex root \'root\' and \'conj(root)\'\r\n\t\t\t\t\tres.x[ i + 1 ] = trace_interval[ 0 ] - 1.0;\r\n\t\t\t\t\tskip_next = true;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif( i < DEGREE - 1 )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tres.x[ i + 2 ] = trace_interval[ 0 ] - 1.0;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfloat p = 2.0 * root.re;\r\n\t\t\t\t\t\tfloat q = -( root.re * root.re + root.im * root.im );\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tc[ DEGREE - i - 0 ] += 0.0;\r\n\t\t\t\t\t\tc[ DEGREE - i - 1 ] += c[ DEGREE - i - 0 ] * p;\r\n\t\t\t\t\t\tc[ DEGREE - i - 2 ] += c[ DEGREE - i - 0 ] * q + c[ DEGREE - i - 1 ] * p;\r\n\t\t\t\t\t\tfor( int j = DEGREE - i - 2; j > -1; j-- )\r\n\t\t\t\t\t\t\tif( j <= DEGREE - i - 3 && j > 1 )\r\n\t\t\t\t\t\t\t\tc[ j ] += c[ j + 2 ] * q + c[ j + 1 ] * p;\r\n\t\t\t\t\t\tfor( int j = 2; j <= DEGREE - i; j++ )\r\n\t\t\t\t\t\t\t\tc[ j - 2 ] = c[ j ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// sort roots\r\n\tbubble_sort( res.x );\r\n\t\r\n\t// validate roots\r\n\tfor( int i = 0; i < DEGREE + 2; i++ )\r\n\t\tres.valid[ i ] = contains( trace_interval, res.x[ i ] );\r\n\t\r\n\treturn res;\r\n}\r\n#endif\r\n#ifdef METHOD_MULLER\r\nfloat epsilon = 0.0001;\r\nstruct complex\r\n{\r\n\tfloat re;\r\n\tfloat im;\r\n};\r\n\r\ncomplex conj( complex z ) { z.im = -z.im; return z; }\r\nfloat sabs( complex z ) { return abs( z.re ) + abs( z.im ); }\r\nfloat magnitude( complex z ) { return sqrt( z.re * z.re + z.im * z.im ); }\r\n\r\ncomplex add( float x, complex z ) { z.re = x + z.re; return z; }\r\ncomplex add( complex z, float x ) { z.re = z.re + x; return z; }\r\ncomplex add( complex z1, complex z2 ) { return complex( z1.re + z2.re, z1.im + z2.im ); }\r\n\r\ncomplex sub( float x, complex z ) " ) + string( "{ z.re = x - z.re; return z; }\r\ncomplex sub( complex z, float x ) { z.re = z.re - x; return z; }\r\ncomplex sub( complex z1, complex z2 ) { return complex( z1.re - z2.re, z1.im - z2.im ); }\r\n\r\ncomplex mult( float x, complex z ) { return complex( x * z.re, x * z.im ); }\r\ncomplex mult( complex z, float x ) { return complex( x * z.re, x * z.im ); }\r\ncomplex mult( complex z1, complex z2 ) { return complex( z1.re * z2.re - z1.im * z2.im, z1.re * z2.im + z1.im * z2.re ); }\r\n\r\ncomplex div( complex z, float x ) { return complex( z.re / x, z.im / x ); }\r\ncomplex div( float x, complex z ) { float tmp = z.re * z.re + z.im * z.im; return complex( ( x * z.re ) / tmp, -( x * z.im ) / tmp ); }\r\ncomplex div( complex z1, complex z2 ) { float tmp = z2.re * z2.re + z2.im * z2.im; return complex( ( z1.re * z2.re + z1.im * z2.im ) / tmp, ( z1.im * z2.re - z1.re * z2.im ) / tmp ); }\r\n\r\ncomplex square( complex z ) { return complex( z.re * z.re - z.im * z.im, 2.0 * z.re * z.im ); }\r\n\r\ncomplex complex_sqrt( complex z )\r\n{\r\n\tcomplex c;\r\n\tif( ( z.re == 0.0 ) && ( z.im == 0.0 ) )\r\n\t{\r\n\t\tc = z;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfloat x, y, w, r;\r\n\t\tx = abs( z.re );\r\n\t\ty = abs( z.im );\r\n\t\tif( x >= y )\r\n\t\t{\r\n\t\t\tr = y / x;\r\n\t\t\tw = sqrt( x ) * sqrt( 0.5 * ( 1.0 + sqrt( 1.0 + r * r ) ) );\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tr = x / y;\r\n\t\t\tw = sqrt( y ) * sqrt( 0.5 * ( r + sqrt( 1.0 + r * r ) ) );\r\n\t\t}\r\n\t\tif( z.re >= 0.0 )\r\n\t\t{\r\n\t\t\tc.re = w;\r\n\t\t\tc.im = z.im / ( 2.0 * w );\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif( z.im >= 0.0 ) \r\n\t\t\t\tc.im = w;\r\n\t\t\telse\r\n\t\t\t\tc.im = -w;\r\n\t\t\tc.re = z.im / ( 2.0 * c.im );\r\n\t\t}\r\n\t}\r\n\treturn c;\r\n}\r\n\r\nfloat ca[ SIZE ];\r\n\r\ncomplex muller( int degree )\r\n{\r\n\t// Startwerte einstellen\r\n\tcomplex a = complex( 1.0, 0.0 );\r\n\tcomplex x0 = complex( -1.0, 0.0 ), f0 = complex( ca[ 0 ] - ca[ 1 ] + ca[ 2 ], 0.0 );\r\n\tcomplex x1 = complex( 1.0, 0.0 ), f1 = complex( ca[ 0 ] + ca[ 1 ] + ca[ 2 ], 0.0 );\r\n\tcomplex x2 = complex( 0.0, 0.0 );\r\n\tcomplex f2 = complex( ca[ 0 ], 0.0 );\r\n\t\r\n\tbool root_found = false;\r\n\twhile( !root_found )\r\n\t{\r\n\t\t// eigentlich würde es reichen, wenn diese Bedingung in der while-Schleife geprüft wird,\r\n\t\t// aber dann klappt\'s nicht mehr -> compiler bug\r\n\t\tif( sabs( f2 ) != 0.0 && magnitude( a ) > 0.00001 * magnitude( x2 ) )\r\n\t\t{\r\n\t\t\t// neue Näherung generieren\r\n\t\t\tcomplex q = div( sub( x2, x1 ), sub( x1, x0 ) );\r\n\t\t\t\r\n\t\t\tcomplex A = add( sub( mult( q, f2 ), mult( mult( q, add( 1.0, q ) ), f1 ) ), mult( square( q ), f0 ) );\r\n\t\t\tcomplex B = add( sub( mult( add( mult( 2.0, q ), 1.0 ), f2 ), mult( square( add( 1.0, q ) ), f1 ) ), mult( square( q ), f0 ) );\r\n\t\t\tcomplex C = mult( add( 1.0, q ), f2 );\r\n\t\t\t\r\n\t\t\tcomplex sqrt_term = complex_sqrt( sub( square( B ), mult( 4.0, mult( A, C ) ) ) );\r\n\t\t\tcomplex denom1 = add( B, sqrt_term );\r\n\t\t\tcomplex denom2 = sub( B, sqrt_term );\r\n\t\t\t\r\n\t\t\tif( magnitude( denom1 ) > magnitude( denom2 ) )\r\n\t\t\t\ta = mult( sub( x2, x1 ), div( mult( 2.0, C ), denom1 ) );\r\n\t\t\telse\r\n\t\t\t\ta = mult( sub( x2, x1 ), div( mult( 2.0, C ), denom2 ) );\r\n\t\t\t\r\n\t\t\tcomplex x2_tmp = sub( x2, a );\r\n\t\t\tcomplex f2_tmp = complex( ca[ degree ], 0.0 );\r\n\t\t\tfor( int i = degree - 1; i >= 0; i-- )\r\n\t\t\t\tf2_tmp = add( mult( f2_tmp, x2_tmp ), ca[ i ] );\r\n\t\t\t\r\n\t\t\tx0 = x1; f0 = f1;\r\n\t\t\tx1 = x2; f1 = f2;\r\n\t\t\tx2 = x2_tmp; f2 = f2_tmp;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\troot_found = true;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn x2;\r\n}\r\n\r\nvoid bubble_sort( inout float a[ DEGREE + 2 ] )\r\n{\r\n\tfor( int i = 1; i < DEGREE + 2; i++ )\r\n\t{\r\n\t\tfor( int j = 0; j < DEGREE + 2 - i; j++ )\r\n\t\t{\r\n\t\t\tif( a[ j ] > a[ j + 1 ] )\r\n\t\t\t{\r\n\t\t\t\tfloat temp = a[ j ];\r\n\t\t\t\ta[ j ] = a[ j + 1 ];\r\n\t\t\t\ta[ j + 1 ] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstruct roots\r\n{\r\n\tfloat x[ DEGREE + 2 ];\r\n\tbool valid[ DEGREE" ) + string( " + 2 ];\r\n};\r\n\r\nbool contains( const in vec2 interval, const in float value )\r\n{\r\n\treturn interval[ 0 ] < value && value < interval[ 1 ];\r\n}\r\n\r\nfloat solve_linear() { return -ca[ 0 ] / ca[ 1 ]; }\r\nvoid solve_quadric( out float x1, out float x2, const in vec2 trace_interval )\r\n{\r\n\tfloat diskriminante = ca[ 1 ] * ca[ 1 ] - 4.0 * ca[ 2 ] * ca[ 0 ];\r\n\tif( diskriminante >= 0.0 )\r\n\t{\r\n\t\tfloat q = -0.5 * ( ca[ 1 ] + sign( ca[ 1 ] ) * sqrt( diskriminante ) );\r\n\t\tx1 = q / ca[ 2 ];\r\n\t\tx2 = ca[ 0 ] / q;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tx1 = x2 = trace_interval[ 0 ] - 1.0;\r\n\t}\r\n}\r\n\r\nroots solve( const in polynomial p, const in vec2 trace_interval )\r\n{\r\n\t// create complex coefficient array from real coefficient array\r\n\tfloat scale = abs( p.a[ DEGREE ] );\r\n\tif( scale <= 0.0000001 )\r\n\t\tscale = 1.0;\r\n\tfor( int i = 0; i < SIZE; i++ )\r\n\t\tca[ i ] = p.a[ i ] / scale;\r\n\t\r\n\t// init result array\r\n\troots res;\r\n\tres.x[ 0 ] = trace_interval[ 0 ];\r\n\tres.valid[ 0 ] = false;\r\n\tres.x[ DEGREE + 1 ] = trace_interval[ 1 ];\t\r\n\tres.valid[ DEGREE + 1 ] = false;\r\n\r\n\t// solve individual root successively\r\n\tbool skip_next = false;\r\n\tfor( int i = 0; i < DEGREE; i++ )\r\n\t{\r\n\t\tif( skip_next )\r\n\t\t{\r\n\t\t\tskip_next = false;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif( DEGREE - i == 1 )\r\n\t\t\t{\r\n\t\t\t\tres.x[ i + 1 ] = solve_linear();\r\n\t\t\t}\r\n\t\t\telse if( DEGREE - i == 2 )\r\n\t\t\t{\r\n\t\t\t\tsolve_quadric( res.x[ i + 1 ], res.x[ i + 2 ], trace_interval );\r\n\t\t\t\tskip_next = true;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcomplex root = muller( DEGREE - i );\r\n\t\r\n\t\t\t\tif( abs( root.im ) < 1e-04 * abs( root.re ) )\r\n\t\t\t\t{\r\n\t\t\t\t\t// deflate real root \'root.re\'\r\n\t\t\t\t\tres.x[ i + 1 ] = root.re;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfloat oldc;\r\n\t\t\t\t\tfloat newc = ca[ DEGREE - i ];\r\n\t\t\t\t\tfor( int j = DEGREE - i - 1; j > -1; j-- )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toldc = ca[ j ];\r\n\t\t\t\t\t\tca[ j ] = newc;\r\n\t\t\t\t\t\tnewc = oldc + newc * root.re;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// deflate complex root \'root\' and \'conj(root)\'\r\n\t\t\t\t\tres.x[ i + 1 ] = trace_interval[ 0 ] - 1.0;\r\n\t\t\t\t\tskip_next = true;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif( i < DEGREE - 1 )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tres.x[ i + 2 ] = trace_interval[ 0 ] - 1.0;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfloat p = 2.0 * root.re;\r\n\t\t\t\t\t\tfloat q = -( root.re * root.re + root.im * root.im );\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tca[ DEGREE - i - 0 ] += 0.0;\r\n\t\t\t\t\t\tca[ DEGREE - i - 1 ] += ca[ DEGREE - i - 0 ] * p;\r\n\t\t\t\t\t\tca[ DEGREE - i - 2 ] += ca[ DEGREE - i - 0 ] * q + ca[ DEGREE - i - 1 ] * p;\r\n\t\t\t\t\t\tfor( int j = DEGREE - i - 2; j > -1; j-- )\r\n\t\t\t\t\t\t\tif( j <= DEGREE - i - 3 && j > 1 )\r\n\t\t\t\t\t\t\t\tca[ j ] += ca[ j + 2 ] * q + ca[ j + 1 ] * p;\r\n\t\t\t\t\t\tfor( int j = 2; j <= DEGREE - i; j++ )\r\n\t\t\t\t\t\t\t\tca[ j - 2 ] = ca[ j ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// sort roots\r\n\tbubble_sort( res.x );\r\n\t\r\n\t// validate roots\r\n\tfor( int i = 0; i < DEGREE + 2; i++ )\r\n\t\tres.valid[ i ] = contains( trace_interval, res.x[ i ] );\r\n\t\r\n\treturn res;\r\n}\r\n#endif\r\n#ifdef METHOD_FORMULA\r\nfloat epsilon = 0.0001;\r\nstruct roots\r\n{\r\n\tfloat x[ DEGREE + 2 ];\r\n\tbool valid[ DEGREE + 2 ];\r\n};\r\nvoid correct( inout float x1, inout float x2 ) { if( x1 > x2 ) { float tmp = x1; x1 = x2; x2 = tmp; } }\r\nroots init_roots( vec2 trace_interval )\r\n{\r\n\troots r;\r\n\tfor( int i = 0; i < DEGREE + 2; i++ )\r\n\t{\r\n\t\tr.x[ i ] = trace_interval[ 0 ] - 1.0;\r\n\t\tr.valid[ i ] = false;\r\n\t}\r\n\treturn r;\r\n}\r\n#if DEGREE == 1\r\nroots solve( const in polynomial p, const in vec2 trace_interval )\r\n{\r\n\troots res = init_roots( trace_interval );\r\n\tres.x[ 1 ] = -p.a[ 0 ] / p.a[ 1 ];\r\n\tres.valid[ 1 ] = res.x[ 1 ] > trace_interval[ 0 ] && res.x[ 1 ] < trace_interval[ 1 ];\r\n\treturn res;\r\n}\r\n#endif\r\n#if " ) + string( "DEGREE == 2\r\nroots solve( const in polynomial p, const in vec2 trace_interval )\r\n{\r\n\troots res = init_roots( trace_interval );\r\n\t\r\n\tfloat diskriminante = p.a[ 1 ] * p.a[ 1 ] - 4.0 * p.a[ 2 ] * p.a[ 0 ];\r\n\tif( diskriminante >= 0.0 )\r\n\t{\r\n\t\tfloat q = -0.5 * ( p.a[ 1 ] + sign( p.a[ 1 ] ) * sqrt( diskriminante ) );\r\n\t\tres.x[ 1 ] = q / p.a[ 2 ];\r\n\t\tres.x[ 2 ] = p.a[ 0 ] / q;\r\n\t\tcorrect( res.x[ 1 ], res.x[ 2 ] );\r\n\t}\r\n\tres.valid[ 1 ] = res.x[ 1 ] > trace_interval[ 0 ] && res.x[ 1 ] < trace_interval[ 1 ];\r\n\tres.valid[ 2 ] = res.x[ 2 ] > trace_interval[ 0 ] && res.x[ 2 ] < trace_interval[ 1 ];\r\n\treturn res;\r\n}\r\n#endif\r\n#if DEGREE == 3\r\nroots solve( const in polynomial p, const in vec2 trace_interval )\r\n{\r\n\troots res = init_roots( trace_interval );\r\n\t\r\n//\tif( abs( p.a[ 3 ] / p.a[ 2 ] ) < 10e-4 )\r\n//\t\tdiscard;\r\n\t\r\n\t#define SIN60 0.86602540378443864675\r\n\t#define HYPOT(x,y) (sqrt(x*x+y*y))\r\n\t\t\r\n\t\tfloat A, B, C;\r\n\t\tA = p.a[ 2 ] / p.a[ 3 ]; // normalisieren\r\n\t\tB = p.a[ 1 ] / p.a[ 3 ]; // normalisieren\r\n\t\tC = p.a[ 0 ] / p.a[ 3 ]; // normalisieren\r\n\t\r\n\t\tfloat Q = ( A * A - 3.0 * B ) / 9.0;\r\n\t\tfloat R = ( 2.0 * A * A * A - 9.0 * A * B + 27.0 * C ) / 54.0;\r\n\t\r\n\t\t// diskriminantenregel!!! (lässt sich aus R und Q bilden)\r\n\t\tif( R * R < Q * Q * Q )\r\n\t\t{\r\n\t\t\t// three real roots\r\n\t\t\t/*\r\n\t\t\t#define PI 3.1415926535897932384626433832795\r\n\t\t\tfloat theta = acos( R / sqrt( Q * Q * Q ) );\r\n\t\t\troots[ 0 ] = -2.0 * sqrt( Q ) * cos( theta / 3.0 ) - A / 3.0;\r\n\t\t\troots[ 1 ] = -2.0 * sqrt( Q ) * cos( ( theta + 2.0 * PI ) / 3.0 ) - A / 3.0;\r\n\t\t\troots[ 2 ] = -2.0 * sqrt( Q ) * cos( ( theta - 2.0 * PI ) / 3.0 ) - A / 3.0;\r\n\t\t\t#undef PI\r\n\t\t\t*/\r\n\t\t\t\r\n\t\t\tfloat a0 = C;\r\n\t\t\tfloat a1 = B;\r\n\t\t\tfloat a2 = A / 3.0;\r\n\t\t\r\n\t\t\tfloat q = a1 / 3.0 - a2*a2;\r\n\t\t\tfloat r = ( a1 * a2 - a0 ) * 0.5  - a2 * a2 * a2 ;\r\n\t\r\n\t\t\tfloat d = q*q*q + r*r;\r\n\t\r\n\t\t\td = sqrt( -d );\r\n\t\t\tq = atan( d, r ) / 3.0;\r\n\t\t\tr = pow( HYPOT( d, r ), 1.0 / 3.0 );\r\n\t\t\r\n\t\t\t{\r\n\t\t\t\tfloat s = ( 2.0 * r ) * cos( q );\r\n\t\t\t\tfloat t = abs( 2.0 * r * sin( q ) ) * SIN60;\r\n\t\t\t\t\r\n\t\t\t\tres.x[1] = s - A / 3.0;\r\n\t\t\t\tres.x[2] = -( 0.5 * s ) - A / 3.0 - t;\r\n\t\t\t\tres.x[3] = -( 0.5 * s ) - A / 3.0 + t;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tfloat X = -sign( R ) * pow( abs( R ) + sqrt( R * R - Q * Q * Q ), 1.0 / 3.0 );\r\n\t\t\tfloat Y = ( abs( X ) < 1e-10 ) ? 0.0 : Q / X;\r\n\t\t\t\r\n\t\t\t// first root is ...\r\n\t\t\tres.x[ 1 ] = ( X + Y ) - A / 3.0;\r\n\t\t\t\t\t\r\n\t\t\tif( abs( X - Y ) < 1e-10 )\r\n\t\t\t{\r\n\t\t\t\t// ... second and third root are also real\r\n\t\t\t\tres.x[ 2 ] = -0.5 * ( X + Y ) - A / 3.0;\r\n\t\t\t\tres.x[ 3 ] = -0.5 * ( X + Y ) - A / 3.0;\r\n\t\t\t}\r\n\t\t}\r\n\t#undef SIN60\r\n\t#undef HYPOT\r\n\t\r\n\t// sort\r\n\tcorrect( res.x[ 1 ], res.x[ 2 ] );\r\n\tcorrect( res.x[ 2 ], res.x[ 3 ] );\r\n\tcorrect( res.x[ 1 ], res.x[ 2 ] );\r\n\t\r\n\t// validate\r\n\tres.valid[ 1 ] = res.x[ 1 ] > trace_interval[ 0 ] && res.x[ 1 ] < trace_interval[ 1 ];\r\n\tres.valid[ 2 ] = res.x[ 2 ] > trace_interval[ 0 ] && res.x[ 2 ] < trace_interval[ 1 ];\r\n\tres.valid[ 3 ] = res.x[ 3 ] > trace_interval[ 0 ] && res.x[ 3 ] < trace_interval[ 1 ];\r\n\t\r\n\treturn res;\r\n}\r\n#endif\r\n#if DEGREE == 4\r\nint solve_quadratic( float illegal, float a[ 3 ], out float roots[ 2 ] )\r\n{\r\n\troots[ 0 ] = roots[ 1 ] = illegal;\r\n\tint num = 0;\r\n\r\n\tfloat diskriminante = a[ 1 ] * a[ 1 ] - 4.0 * a[ 2 ] * a[ 0 ];\r\n\tif( diskriminante >= 0.0 )\r\n\t{\r\n\t\tfloat q = -0.5 * ( a[ 1 ] + sign( a[ 1 ] ) * sqrt( diskriminante ) );\r\n\t\troots[ 0 ] = q / a[ 2 ];\r\n\t\troots[ 1 ] = a[ 0 ] / q;\r\n\t\tnum = 2;\r\n\t}\r\n\t\r\n\treturn num;\r\n}\r\n\r\n// Lösungsmöglichkeiten siehe http://en.wikipedia.org/wiki/Cubic_equation\r\n// Cardano\'s method\r\n// Lagrange resolvents\r\n// Chebyshev radicals\r\nint solve_cubic( float illegal, float a[ 4 ], out flo" ) + string( "at roots[ 3 ] )\r\n{\r\n\tint num;\r\n#define SIN60 0.86602540378443864675\r\n#define HYPOT(x,y) (sqrt(x*x+y*y))\r\n\r\n\troots[ 0 ] = roots[ 1 ] = roots[ 2 ] = illegal;\r\n\r\n\tfloat A, B, C;\r\n\tA = a[ 2 ] / a[ 3 ]; // normalisieren\r\n\tB = a[ 1 ] / a[ 3 ]; // normalisieren\r\n\tC = a[ 0 ] / a[ 3 ]; // normalisieren\r\n\r\n\tfloat Q = ( A * A - 3.0 * B ) / 9.0;\r\n\tfloat R = ( 2.0 * A * A * A - 9.0 * A * B + 27.0 * C ) / 54.0;\r\n\r\n\t// diskriminantenregel!!! (lässt sich aus R und Q bilden)\r\n\tif( R * R < Q * Q * Q )\r\n\t{\r\n\t\tfloat a0 = C;\r\n\t\tfloat a1 = B;\r\n\t\tfloat a2 = A / 3.0;\r\n\t\r\n\t\tfloat q = a1 / 3.0 - a2*a2;\r\n\t\tfloat r = ( a1 * a2 - a0 ) * 0.5  - a2 * a2 * a2 ;\r\n\r\n\t\tfloat d = q*q*q + r*r;\r\n\r\n\t\td = sqrt( -d );\r\n\t\tq = atan( d, r ) / 3.0;\r\n\t\tr = pow( HYPOT( d, r ), 1.0 / 3.0 );\r\n\t\r\n\t\t{\r\n\t\t\tfloat s = ( 2.0 * r ) * cos( q );\r\n\t\t\tfloat t = abs( 2.0 * r * sin( q ) ) * SIN60;\r\n\t\t\t\r\n\t\t\troots[0] = s - A / 3.0;\r\n\t\t\troots[1] = -( 0.5 * s ) - A / 3.0 - t;\r\n\t\t\troots[2] = -( 0.5 * s ) - A / 3.0 + t;\r\n\t\t}\r\n\t\tnum = 3;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tfloat X = -sign( R ) * pow( abs( R ) + sqrt( R * R - Q * Q * Q ), 1.0 / 3.0 );\r\n\t\tfloat Y = ( abs( X ) < 1e-10 ) ? 0.0 : Q / X;\r\n\t\t\r\n\t\t// first root is ...\r\n\t\troots[ 0 ] = ( X + Y ) - A / 3.0;\r\n\t\t\r\n\t\tnum = 1;\r\n\t\t\r\n\t\tif( abs( X - Y ) < 1e-10 )\r\n\t\t{\r\n\t\t\t// ... second and third root are also real\r\n\t\t\troots[ 1 ] = -0.5 * ( X + Y ) - A / 3.0;\r\n\t\t\troots[ 2 ] = -0.5 * ( X + Y ) - A / 3.0;\r\n\t\t\tnum = 3;\r\n\t\t}\r\n\t}\r\n#undef SIN60\r\n#undef HYPOT\r\n\r\n\treturn num;\r\n}\r\n\r\nroots solve( const in polynomial p, const in vec2 trace_interval )\r\n{\r\n\troots res = init_roots( trace_interval );\r\n\r\n\tfloat illegal = trace_interval[ 0 ] - 1.0;\r\n\tfloat a3,a2,a1,a0;\r\n\tfloat resolvant[ 4 ];\r\n\tfloat resolvant_roots[ 3 ];\r\n\tint resolvant_num_roots;\r\n\tint num = 0;\r\n\r\n\ta0 = p.a[0] / p.a[4];\r\n\ta1 = p.a[1] / p.a[4];\r\n\ta2 = p.a[2] / p.a[4];\r\n\ta3 = p.a[3] / p.a[4];\r\n\r\n\tresolvant[0] = -( a1*a1 + a0 * a3 * a3  - 4.0 * a0 * a2 );\r\n\tresolvant[1] = a1*a3 - 4.0 * a0;\r\n\tresolvant[2] = -a2;\r\n\tresolvant[3] = 1.0;\r\n\r\n\tresolvant_num_roots = solve_cubic( illegal, resolvant, resolvant_roots );\r\n\r\n\tbool found = false;\r\n\tfor( int i = 0 ; i < 3 ; i++ )\r\n\t{\r\n\t\tif( !found && i < resolvant_num_roots )\r\n\t\t{\r\n\t\t\tfloat u,s,t;\r\n\t\t\tu = resolvant_roots[i];\r\n\t\r\n\t\t\ts = a3*a3 / 4.0 + u - a2;\r\n\t\t\tt = u * u / 4.0 - a0;\r\n\t\r\n\t\t\tif( s >= 0.0 && t >= 0.0 )\r\n\t\t\t{\r\n\t\t\t\tfloat quad[3];\r\n\t\t\t\t\r\n\t\t\t\ts = sqrt(s);\r\n\t\t\t\tt = sqrt(t);\r\n\t\t\t\t\r\n\t\t\t\tif( sign(s*t) != sign(a3 * u / 2.0 - a1) )\r\n\t\t\t\t\tt = -t;\r\n\t\r\n\t\t\t\tquad[0] = u / 2.0 + t;\r\n\t\t\t\tquad[1] = a3 / 2.0 + s;\r\n\t\t\t\tquad[2] = 1.0;\r\n\t\r\n\t\t\t\tfloat quad_roots[ 2 ];\r\n\t\t\t\tnum += solve_quadratic( illegal,quad,quad_roots);\r\n\t\r\n\t\t\t\tquad[0] = u / 2.0 - t;\r\n\t\t\t\tquad[1] = a3 / 2.0 - s;\r\n\t\r\n\t\t\t\tif( num == 0 )\r\n\t\t\t\t{\r\n\t\t\t\t\tnum += solve_quadratic( illegal,quad,quad_roots);\r\n\t\t\t\t\tres.x[ 1 ] = quad_roots[ 0 ];\r\n\t\t\t\t\tres.x[ 2 ] = quad_roots[ 1 ];\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tres.x[ 1 ] = quad_roots[ 0 ];\r\n\t\t\t\t\tres.x[ 2 ] = quad_roots[ 1 ];\r\n\t\t\t\t\tnum += solve_quadratic( illegal,quad,quad_roots);\r\n\t\t\t\t\tres.x[ 3 ] = quad_roots[ 0 ];\r\n\t\t\t\t\tres.x[ 4 ] = quad_roots[ 1 ];\r\n\t\t\t\t}\r\n\t\t\t\tfound = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// sort\r\n\tcorrect( res.x[ 1 ], res.x[ 2 ] );\r\n\tcorrect( res.x[ 2 ], res.x[ 3 ] );\r\n\tcorrect( res.x[ 3 ], res.x[ 4 ] );\r\n\tcorrect( res.x[ 1 ], res.x[ 2 ] );\r\n\tcorrect( res.x[ 2 ], res.x[ 3 ] );\r\n\tcorrect( res.x[ 1 ], res.x[ 2 ] );\r\n\t\r\n\t// validate\r\n\tres.valid[ 1 ] = res.x[ 1 ] > trace_interval[ 0 ] && res.x[ 1 ] < trace_interval[ 1 ];\r\n\tres.valid[ 2 ] = res.x[ 2 ] > trace_interval[ 0 ] && res.x[ 2 ] < trace_interval[ 1 ];" ) + string( "\r\n\tres.valid[ 3 ] = res.x[ 3 ] > trace_interval[ 0 ] && res.x[ 3 ] < trace_interval[ 1 ];\r\n\tres.valid[ 4 ] = res.x[ 4 ] > trace_interval[ 0 ] && res.x[ 4 ] < trace_interval[ 1 ];\r\n\t\r\n\treturn res;\r\n}\r\n#endif\r\n#if DEGREE > 4\r\n#error Threre are no formulas for degree above 4!\r\n#endif\r\n#endif\r\n// all coordinates have to be in eye space!\r\n// vectors have to be normalized\r\nvec4 illuminate_one( vec3 eye_pos, vec3 hit_pos, vec3 n, gl_MaterialParameters material, gl_LightSourceParameters light, gl_LightProducts product )\r\n{\r\n\tvec3 vp = normalize( light.position.xyz - hit_pos );\r\n\tfloat vp_length = length( light.position.xyz - hit_pos );\r\n\tvec3 h = normalize( vp + normalize( eye_pos - hit_pos ) );\r\n\t\r\n\tfloat pv_sdli = dot( -vp, normalize( light.spotDirection ) );\r\n\tvec2 mix_cond = vec2(\tfloat( light.position.w == 0.0 ),\t\t// attenuation\r\n\t\t\t\t\t\t\tfloat( light.spotCutoff == 180.0 ) );\t// spot\r\n\tvec2 mix_vec_a = vec2(\t1.0 / ( light.constantAttenuation + ( light.linearAttenuation + light.quadraticAttenuation * vp_length ) * vp_length ),\t// attenuation\r\n\t\t\t\t\t\t\tpow( pv_sdli, light.spotExponent ) );\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// spot\r\n\tvec2 mix_vec_b = vec2(\t1.0,\t// attenuation\r\n\t\t\t\t\t\t\t1.0 );\t// spot\r\n\tvec2 mixed_vec = mix( mix_vec_a, mix_vec_b, mix_cond );\r\n\t\r\n\tfloat att = mixed_vec[ 0 ];\r\n\tfloat spot = mixed_vec[ 1 ] * float( pv_sdli >= light.spotCosCutoff );\r\n\tfloat f = float( dot( n, vp ) != 0.0 );\r\n\t\r\n\treturn att * spot * (\tproduct.ambient + // ambient\r\n\t\t\t\t\t\t\tdot( n, vp ) * product.diffuse + // diffuse\r\n\t\t\t\t\t\t\t+ f * pow( max( 0.0, dot( n, h ) ), material.shininess ) * product.specular ); // specular\r\n}\r\n\r\nvec4 illuminate( vec3 hit_pos, vec3 n )\r\n{\r\n\tvec3 eye_pos = vec3( 0.0 );\r\n\tbool use_front_material = dot( n, eye_pos - hit_pos ) <= 0.0;\r\n\tgl_MaterialParameters material;\r\n\tvec4 color;\r\n\tif( use_front_material )\r\n\t{\r\n\t\tmaterial = gl_FrontMaterial;\r\n\t\tcolor = gl_FrontLightModelProduct.sceneColor;\r\n\t\tn = -n;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tmaterial = gl_BackMaterial;\r\n\t\tcolor = gl_BackLightModelProduct.sceneColor;\r\n\t}\r\n\t\r\n\tgl_LightSourceParameters light;\r\n\tgl_LightProducts product;\r\n\tfor( int i = 0; i < MAX_LIGHTS; i++ )\r\n\t{\r\n\t\tlight = gl_LightSource[ i ];\r\n\t\tif( use_front_material ) product = gl_FrontLightProduct[ i ]; else product = gl_BackLightProduct[ i ];\r\n\t\tcolor += mix( vec4( 0.0 ), illuminate_one( eye_pos, hit_pos, n, material, light, product ), float( light.ambient.a != 0.0 ) );\r\n\t}\r\n\r\n\tcolor.a = material.diffuse.a;\r\n\r\n\treturn color;\r\n}\r\n/*\r\nvec4 illuminate( vec3 hit_pos, vec3 n )\r\n{\r\n\tvec3 eye_pos = vec3( 0.0 );\r\n\tvec3 vp = normalize( gl_LightSource[ 0 ].position.xyz - hit_pos );\r\n\tfloat vp_length = length( gl_LightSource[ 0 ].position.xyz - hit_pos );\r\n\tvec3 h = normalize( vp + normalize( eye_pos - hit_pos ) );\r\n\tfloat f = ( dot( n, vp ) != 0.0 ) ? 1.0 : 0.0;\r\n\tfloat att, spot;\r\n\r\n\t// calculate attenuation\r\n\tif( gl_LightSource[ 0 ].position.w != 0.0 )\r\n\t\tatt = 1.0 / ( gl_LightSource[ 0 ].constantAttenuation + ( gl_LightSource[ 0 ].linearAttenuation + gl_LightSource[ 0 ].quadraticAttenuation * vp_length ) * vp_length );\r\n\telse\r\n\t\tatt = 1.0;\r\n\r\n\tfloat pv_sdli = dot( -vp, normalize( gl_LightSource[ 0 ].spotDirection ) );\r\n\tif( gl_LightSource[ 0 ].spotCutoff == 180.0 )\r\n\t\tspot = 1.0;\r\n\telse if( pv_sdli < gl_LightSource[ 0 ].spotCosCutoff )\r\n\t\tspot = 0.0;\r\n\telse\r\n\t\tspot = pow( pv_sdli, gl_LightSource[ 0 ].spotExponent );\r\n\t\r\n\t\r\n\tgl_MaterialParameters material;\r\n\tgl_LightProducts product;\r\n\tif( dot( n, eye_pos - hit_pos ) <= 0.0 )\r\n\t{\r\n\t\tmaterial = gl_FrontMaterial;\r\n\t\tproduct = gl_FrontLightProduct[ 0 ];\r\n\t\tn = -n;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tmaterial = gl_BackMaterial;\r\n\t\tproduct = gl_BackLightProduct[ 0 ];\r\n\t}\r\n\r\n\tvec4 ambient  = product.ambient;\r\n\tvec4 diffuse  = dot( n, vp ) * prod" ) + string( "uct.diffuse;\r\n\tvec4 specular = clamp( f * pow( max( 0.0, dot( n, h ) ), material.shininess ) * product.specular, 0.0, 1.0 );\r\n\t\r\n\tvec4 color = gl_FrontLightModelProduct.sceneColor + att * spot * ( ambient + diffuse + specular );\r\n\tcolor.a = material.diffuse.a;\r\n\r\n\treturn color;\r\n}\r\n*/\r\nfloat z_buffer_depth( vec3 p )\r\n{\r\n\tvec4 proj_p = gl_ProjectionMatrix * vec4( p, 1.0 );\r\n\tfloat a = gl_DepthRange.far / gl_DepthRange.diff;\r\n\tfloat b = gl_DepthRange.far * gl_DepthRange.near / ( - gl_DepthRange.diff );\r\n\treturn ( proj_p.z / proj_p.w ) * 0.5 + 0.5 ;\r\n}\r\n\r\nvoid process( roots r, vec3 eye, vec3 dir )\r\n{\r\n\tbool any_valid = false;\r\n\tfloat first_root = 0.0;\r\n#ifdef USE_TRANSPARENCY\t\r\n\tif( gl_FrontMaterial.diffuse.a == 1.0 && gl_BackMaterial.diffuse.a == 1.0 )\r\n\t{\r\n#endif\r\n\t\t// just process the first hit (the other hits can\'t be seen anyway)\r\n\t\tfor( int i = 1; i < DEGREE + 2 - 1; i++ )\r\n\t\t{\r\n\t\t\t// assign to first_root if, and only if a valid root comes along and there was no valid root before (=first valid root)\r\n\t\t\tfirst_root = mix( first_root, r.x[ i ], float( r.valid[ i ] && !any_valid ) );\r\n\t\t\tany_valid = any_valid || r.valid[ i ];\r\n\t\t}\r\n\t\t\r\n\t\tif( any_valid )\r\n\t\t{\r\n\t\t\t// illuminate point of first root\r\n\t\t\tvec3 first_hit = eye + first_root * dir;\r\n\t\t\tvec3 eye_space_normal = normalize( ( gl_ModelViewMatrix * surface_transform * vec4( gradient( sse_opt + first_root * ssd_opt ), 0.0 ) ).xyz );\r\n\t\t\tgl_FragColor = illuminate( ese_opt + first_root * esd_opt, eye_space_normal );\r\n#ifndef USE_TRANSPARENCY\r\n\t\t\tgl_FragColor.a = 1.0;\r\n#endif\t\t\t\r\n\t\t\tgl_FragDepth = z_buffer_depth( first_hit );\t\t\t\r\n\t\t}\r\n\t\telse\r\n\t\t\t// surface not hit - discard the pixel\r\n\t\t\tdiscard;\r\n#ifdef USE_TRANSPARENCY\t\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// process all hits with this surface\r\n\t\tgl_FragColor = vec4( 0.0 );\r\n\t\tvec3 first_hit = vec3( 0.0 );\r\n\t\tfor( int i = DEGREE + 2 - 2; i >= 1; i-- )\r\n\t\t{\r\n\t\t\tif( r.valid[ i ] )\r\n\t\t\t{\r\n\t\t\t\t// this is a valid hit\r\n\t\t\t\tany_valid = true;\r\n\t\t\t\tfirst_root = r.x[ i ];\r\n\t\t\t\tfirst_hit = eye + first_root * dir;\r\n\t\t\t\t\r\n\t\t\t\tvec3 eye_space_normal = normalize( ( gl_ModelViewMatrix * surface_transform * vec4( gradient( sse_opt + first_root * ssd_opt ), 0.0 ) ).xyz );\r\n\t\t\t\tvec4 new_color = illuminate( ese_opt + first_root * esd_opt, eye_space_normal );\r\n\t\t\t\tgl_FragColor.rgb = min( vec3( 1.0 ), ( 1.0 - new_color.a ) * gl_FragColor.rgb + new_color.a * new_color.rgb );\r\n\t\t\t\tgl_FragColor.a = ( 1.0 - new_color.a ) * gl_FragColor.a + new_color.a;\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif( any_valid )\r\n\t\t{\r\n\t\t\t// calculate pseudo depth value of first root\r\n\t\t\tgl_FragDepth = z_buffer_depth( first_hit );\r\n\t\t}\r\n\t\telse\r\n\t\t\t// surface not hit - discard the pixel\r\n\t\t\tdiscard;\r\n\t}\r\n#endif\r\n}\r\n\r\nvec2 clip( vec3 o, vec3 d )\r\n{\r\n\tfloat l = length( d );\r\n\td = d / l;\r\n\r\n\tvec2 res;\r\n\tif( clip_to == CLIP_TO_SPHERE )\r\n\t{\r\n\t\t// solve algebraic\r\n\t\tfloat B = dot( o, d );\r\n\t\tfloat C = dot( o, o ) - 1.0;\r\n\t\tfloat D = B * B - C;\r\n\t\t\r\n\t\tif( D < 0.0 )\r\n\t\t\tdiscard;\r\n\t\t\r\n\t\tres = vec2( -B - sqrt( D ), -B + sqrt( D ) );\r\n\t}\r\n\telse if( clip_to == CLIP_TO_CUBE )\r\n\t{\r\n\t\t// liang-barsky\r\n\t\tvec3 plane[ 6 ]; // use value as normal AND point on plane\r\n\t\tplane[ 0 ] = vec3( 1.0, 0.0, 0.0 );\r\n\t\tplane[ 1 ] = vec3( 0.0, 1.0, 0.0 );\r\n\t\tplane[ 2 ] = vec3( 0.0, 0.0, 1.0 );\r\n\t\tplane[ 3 ] = vec3( -1.0, 0.0, 0.0 );\r\n\t\tplane[ 4 ] = vec3( 0.0, -1.0, 0.0 );\r\n\t\tplane[ 5 ] = vec3( 0.0, 0.0, -1.0 );\r\n\t\t\r\n\t\tres = vec2( -2.0, 2.0 ); // max distance is diagonal (=2.0*sqrt(3.0)~=3.4642)\r\n\t\tvec3 p0 = o, p1 = p0 + d;\r\n\t\t\r\n\t\tfor( int i = 0; i < 6; i++ )\r\n\t\t{\r\n\t\t\tfloat angle_ray_plane_normal = dot( plane[ i ], p1 - p0 );\r\n\t\t\tif( angle_ray_plane_normal > 0.0 )\r\n\t\t\t\t// ray is leaving throu" ) + string( "gh this plane\r\n\t\t\t\tres[ 1 ] = min( res[ 1 ], dot( plane[ i ], plane[ i ] - p0 ) / angle_ray_plane_normal );\r\n\t\t\telse if( angle_ray_plane_normal < 0.0 )\r\n\t\t\t\t// ray is entering through this plane\r\n\t\t\t\tres[ 0 ] = max( res[ 0 ], dot( plane[ i ], plane[ i ] - p0 ) / angle_ray_plane_normal );\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tres = vec2( 0.0 );\r\n\t\tdiscard;\r\n\t}\r\n\treturn res / l;\r\n}\r\n\r\nvoid optimize_rays()\r\n{\r\n\tfloat best_start = -dot( clipping_space_eye, clipping_space_dir ) / dot( clipping_space_dir, clipping_space_dir );\r\n\tfloat scale = 2.0 * length( surface_space_dir );\r\n\t\r\n\tese_opt = eye_space_eye + best_start * eye_space_dir;\r\n\tesd_opt = eye_space_dir / scale;\r\n\t\r\n\tcse_opt = clipping_space_eye + best_start * clipping_space_dir;\r\n\tcsd_opt = clipping_space_dir / scale;\r\n\t\r\n\tsse_opt = surface_space_eye + best_start * surface_space_dir;\r\n\tssd_opt = surface_space_dir / scale;\r\n\t\r\n\tepsilon = epsilon / length( esd_opt );\r\n}\r\n\r\n#ifdef METHOD_DESCARTES\r\n/**\r\n * transform rays in a way that afterwards the interval (-1,1)\r\n * can be used for descartes method\r\n */\r\nvoid normalize_interval( vec2 trace_interval )\r\n{\r\n\tfloat ti_length = trace_interval[ 1 ] - trace_interval[ 0 ];\r\n\tfloat shift = 0.5 * ( trace_interval[ 1 ] + trace_interval[ 0 ] );\r\n\tfloat scale = 0.5 * ti_length;\r\n\t\r\n\tese_opt = ese_opt + shift * esd_opt;\r\n\tesd_opt = esd_opt * scale;\r\n\t\r\n\tcse_opt = cse_opt + shift * csd_opt;\r\n\tcsd_opt = csd_opt * scale;\r\n\t\r\n\tsse_opt = sse_opt + shift * ssd_opt;\r\n\tssd_opt = ssd_opt * scale;\r\n}\r\n#endif\r\n\r\n/**\r\n * main method, that guides the overall process\r\n */\r\nvoid main( void )\r\n{\r\n\toptimize_rays();\r\n\t\r\n\t// we will only look for roots in this interval\r\n\tvec2 trace_interval = clip( cse_opt, csd_opt );\r\n\r\n#ifdef METHOD_DESCARTES\r\n\tnormalize_interval( trace_interval );\r\n\ttrace_interval = vec2( -1.0, 1.0 );\r\n#endif\r\n\t\r\n\t// holds coefficients of univariate polynomial f( eye + t * dir )\r\n\tpolynomial p = calc_coefficients( sse_opt, ssd_opt, trace_interval );\r\n\t\r\n\t// solve equation sum_{i=0}^DEGREE a[ i ] * x^i = 0\r\n\troots r = solve( p, trace_interval );\r\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\r\n\tgl_FragDepth = 0.5;\r\n\t\r\n\t// now we can further process the pixel, i.e. illuminate it, calculate it\'s depth value ...\r\n\tprocess( r, ese_opt,esd_opt );\r\n}" ) )
#endif
